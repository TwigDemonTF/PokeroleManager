<!doctype html>

<html lang="en">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Pok√©mon ‚Äî Player View</title>

  <style>
    :root {
      --card-scale: 1.25;
      /* scaled up for player readability */
      --panel-bg: #363636;
      --card-border: #333;
      --muted: #9aa;
      --accent: hotpink;
    }

    body {
      margin: 0;
      font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, Arial;
      background: #222121;
      color: hotpink;
      user-select: none;
    }

    header {
      padding: 14px 20px;
      background: var(--panel-bg);
      border-bottom: 2px solid hotpink;
    }

    header h1 {
      margin: 0;
      font-size: 1.2rem;
    }

    main {
      padding: 20px;
      display: flex;
      justify-content: center;
    }

    /* ---------- CARD ---------- */

    .poke {
      font-size: calc(1rem * var(--card-scale));
      background: var(--panel-bg);
      padding: 1em;
      border-radius: 14px;
      background:
        linear-gradient(var(--panel-bg), var(--panel-bg)) padding-box,
        linear-gradient(to right, black, hotpink) border-box;
      border: 3px solid transparent;
      max-width: 90%;
      width: 100%;
      box-sizing: border-box;
    }

    .head {
      display: flex;
      gap: 0.8em;
      align-items: center;
    }

    .meta h2 {
      margin: 0;
      font-size: 1.4em;
    }

    .sub {
      font-size: 0.85em;
      color: var(--muted);
    }

    /* ---------- TOOLTIP (same behavior as battle page) ---------- */

    .tooltip {
      position: relative;
      display: inline-block;
      cursor: help;
    }

    .tooltip .tooltip-content {
      visibility: hidden;
      opacity: 0;
      transition: opacity 0.15s ease;
      position: absolute;
      z-index: 20;
      background: #111;
      color: #eee;
      border: 1px solid #444;
      border-radius: 6px;
      padding: 10px;
      font-size: 0.8rem;
      width: 240px;
      top: 120%;
      left: 0;
    }

    .tooltip:hover .tooltip-content {
      visibility: visible;
      opacity: 1;
    }

    /* ---------- TYPES / BADGES ---------- */

    .types {
      display: flex;
      gap: 0.5em;
      margin-top: 0.6em;
      flex-wrap: wrap;
    }

    .badge {
      padding: 0.35em 0.6em;
      font-size: 0.8em;
      border-radius: 0.5em;
      background: #222;
      border: 1px solid #444;
      color: white;
    }

    /* ---------- HP BAR (READ-ONLY) ---------- */

    .hp-bar-container {
      margin-top: 1em;
    }

    .hp-bar {
      height: 16px;
      background: #222;
      border-radius: 8px;
      overflow: hidden;
      border: 1px solid #444;
    }

    .hp-bar-fill {
      height: 100%;
      background: #28c76f;
      transition: width 0.2s ease;
    }
    .lethal-hp-bar-fill {
        height: 100%;
        background: #8e44ad;
        transition: width 0.2s ease;   
    }

    .hp-text {
      margin-top: 4px;
      font-size: 0.9em;
      color: var(--muted);
    }

    .lethal-hp-text {
        margin-top: 4px;
        font-size: 0.9em;
        color: var(--muted);
    }

    /* ---------- STAT CIRCLES (READ-ONLY) ---------- */

    .stats {
      display: flex;
      gap: 0.6em;
      margin-top: 1.2em;
      flex-wrap: wrap;
      /* keep all on same line */
      align-items: center;
    }

    .stats .stat-group {
        display: flex;
        gap: 0.6em;
        flex: 0 0 auto;
    }

    .stats .stat-group.right {
      margin-left: auto;
      /* pushes this group to the right */
    }

    .stat {
      background: #222;
      border: 1px solid #444;
      border-radius: 6px;
      padding: 0.4em 0.6em;
      font-size: 0.85em;
    }

    .stat b {
      display: block;
      margin-bottom: 4px;
    }

    .stat-circles {
      display: flex;
      gap: 0.25em;
    }

    .circle {
      width: 0.9em;
      height: 0.9em;
      border-radius: 50%;
      background: #333;
      border: 1px solid #555;
    }

    .circle.filled {
      background: var(--accent);
    }

    .stat-columns {
      display: flex;
      gap: 1em;
      margin-top: 1em;
    }

    .stat-column {
      background: #222;
      border: 1px solid #444;
      border-radius: 6px;
      padding: 0.4em 0.6em;
      font-size: 0.85em;
      flex: 1;
    }

    .stat-column b {
      display: flex;
      flex-direction: column;
      /* title on top, circles below */
      gap: 0.4em;
      margin-bottom: 4px;
      align-items: center;
      /* <-- center title + circles horizontally */
    }


    .stat-row {
      display: flex;
      justify-content: space-between;
      margin-bottom: 4px;
    }

    @media (max-width: 1500px) {
        .stats .stat-group.right {
            margin-left: 0;       /* stop pushing right */
            flex-basis: 100%;     /* force onto its own row */
            justify-content: flex-start;
        }
    }

    /* ---------- MOVES (READ-ONLY + TOOLTIP) ---------- */

    .moves {
      margin-top: 1.4em;
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 0.8em;
    }

    .move-card {
      background: #222;
      border: 1px solid #444;
      border-radius: 8px;
      padding: 0.7em;
      color: white;
    }

    .move-header {
      display: flex;
      justify-content: space-between;
      font-weight: bold;
      margin-bottom: 4px;
    }

    .move-name {
      font-size: 1.05em;
    }

    .move-footer {
      margin-top: 6px;
      font-style: italic;
      opacity: 0.8;
      font-size: 0.85em;
      border-top: 1px solid #555;
      padding-top: 4px;
    }

    ul {
      list-style: none;
      margin: 0;
      padding: 0;
      width: 100%;
      margin-top: 2px;
    }

    li {
      margin-left: px;
    }

    a {
      text-decoration: none;
      color: hotpink;
    }

    a:hover {
      color: lavender;
      transition: .75s;
    }

    /* BAG BRUH */
    .bag {
      margin-top: 1.5em;
      background: #222;
      border: 1px solid #444;
      border-radius: 8px;
      overflow: hidden;
    }

    .bag-header {
      font-weight: bold;
      cursor: pointer;
      color: hotpink;
      user-select: none;
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 1rem;
      border-bottom: hotpink solid 4px;
      border-bottom-left-radius: 12.5px;
      border-bottom-right-radius: 12.5px;
    }

    .bag-header::after {
      content: "‚ñº";
      transition: transform 0.3s ease;
    }

    .bag.open .bag-header::after {
      transform: rotate(-180deg);
    }

    .bag-content {
      display: none;
      margin-top: 0.6em;
      padding-left: 0;
      flex-direction: column;
      gap: 0.5em;
      animation: fadein 0.05s ease-in;
    }

    .bag.open .bag-content {
      display: flex;
    }

    @keyframes fadein {
      from { opacity: 0; }
      to   { opacity: 1; }
    }

    .bag-card {
      background: #222;
      border: 1px solid #444;
      border-radius: 8px;
      padding: 0.6em 1em;
      color: white;
      display: flex;
      flex-direction: column;
      gap: 0.4em;
      margin: 1rem;
      margin-top: 0;
    }

    .bag-card:first-child {
      margin-top: 0;
    }

    .bag-card:hover {
      background: #333;
    }

    .card-top {
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .card-name-category {
      display: flex;
      gap: 0.5em;
      align-items: baseline;
    }

    .item-category {
      font-size: 0.85em;
      color: #aaa;
    }

    .sell-price {
      font-weight: bold;
      font-size: 0.9em;
    }

    .effect {
      font-size: 0.9em;
    }

    .description {
      font-style: italic;
      color: #bbb;
      font-size: 0.85em;
    }

    hr {
      border: 0;
      border-top: 1px solid #555;
      margin: 0.3em 0;
    }

    .equip-btn {
      align-self: flex-start;
      padding: 0.3em 0.8em;
      border: none;
      background: hotpink;
      color: #222;
      font-weight: bold;
      border-radius: 5px;
      cursor: pointer;
      margin-top: 0.5em;
    }

    .equip-btn:hover {
      background: #ff69b4;
    }

  </style>

</head>

<body>
  <header style="display: flex;">
    <h1 style="width: 8%;">Pok√©mon Status</h1>
    <ul style="display: flex;">
      <li><a href="/ItemShop">Item Shop</a></li>
    </ul>
  </header>

  <main>
    <div id="pokemonCard" class="poke"></div>
  </main>

  <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11"></script>


  <script>
    if (window.innerHeight < 1600)
      document.body.style.zoom = "80%";
    let pokemonStatusInterval = null;
    let pokemonStatusSource = null;
    let isBagOpen = false;

    const POKEMON_GUID = '{{ pokemonGuid }}'; // injected by backend
    const GAME_ID = '{{ gameId }}'
    const BASE_URL = "{{ baseUrl }}"

    const statCostRules = {
      core: v => v * 10,
      skills: v => v === 0 ? 6 : v * 8,
      general: v => v === 0 ? 6 : v * 6,
      will: v => v * 3,
      static50: () => 50
    };

    const typeColors = {
      Fire: "#F08030",
      Water: "#6890F0",
      Grass: "#78C850",
      Electric: "#F8D030",
      Ice: "#98D8D8",
      Fighting: "#C03028",
      Poison: "#A040A0",
      Ground: "#E0C068",
      Flying: "#A890F0",
      Psychic: "#F85888",
      Bug: "#A8B820",
      Rock: "#B8A038",
      Ghost: "#705898",
      Dragon: "#7038F8",
      Dark: "#705848",
      Steel: "#B8B8D0",
      Fairy: "#EE99AC",
      Normal: "#A8A878",
    };

    const statCostType = {
      Strength: "core",
      Dexterity: "core",
      Vitality: "core",
      Insight: "core",
      Special: "core",

      Fight: "skills",
      Survival: "skills",
      Contest: "skills",

      Brawl: "general",
      Channel: "general",
      Clash: "general",
      Evasion: "general",
      Alert: "general",
      Athletic: "general",
      Nature: "general",
      Stealth: "general",
      Allure: "general",
      Etiquette: "general",
      Intimidate: "general",
      Perform: "general",

      Will: "will",
      Logic: "static50",
      Instinct: "static50",
      Primal: "static50"
    };

    const PRIORITY_LABELS = {
        n7: "-7",
        n6: "-6",
        n5: "-5",
        n4: "-4",
        n3: "-3",
        n2: "-2",
        n1: "-1",
        n0: "0",
        p1: "+1",
        p2: "+2",
        p3: "+3",
        p4: "+4",
        p5: "+5",
    };

    const ITEM_USE_HANDLERS = {
        heal_pool: openHealPoolSwal,
        //heal_fixed: openHealFixedSwal,
        //revive: openReviveSwal,
        // future effects go brrrrr
    };

    function startPlayerStateStream(pokemonGuid, p) {
      if (pokemonStatusSource) pokemonStatusSource.close();

      pokemonStatusSource = new EventSource(
        `${BASE_URL}/playerStateStream/${GAME_ID}/${pokemonGuid}`
      );

      pokemonStatusSource.onmessage = (event) => {
        const msg = JSON.parse(event.data);
        if (msg.type !== "update") return;

        applyPlayerUpdate(msg.payload, p);
      };

      pokemonStatusSource.onerror = () => {
        console.warn("SSE disconnected, retrying automatically");
      };
    }

    function applyPlayerUpdate(update, p) {
      Object.assign(p, update)

      if ("Health" in update) {
        p.Health = update.Health;
        p._updateHpUI(update.Health, p);
      }

      if ("LethalHealth" in update) {
        p.LethalHealth = update.LethalHealth;
        p._updateLethalHpUi(update.LethalHealth, p)
      }

      if ("Status" in update) {
        p.Status = update.Status;
      }

      if ("ExperiencePoints" in update) {
        p.ExperiencePoints = update.ExperiencePoints;
        updateXpUI(update.ExperiencePoints);
      }

      if ("Apples" in update) {
        p.Apples = update.Apples;
        updateMoneyUI(update.Apples);
      }

      if ("Moves" in update) {
        p.Moves = update.Moves;
        updateMovesUI(update.Moves);
      }

      if ("Bag" in update) {
        loadPokemon()
      }

      if ("HeldItem" in update) {
        p.HeldItem = update.HeldItem;
        updateHeldItemBadge(update.HeldItem);
      }
    }

    function updateXpUI(xp) {
        const el = document.querySelector(".experience");
        if (!el) return;

        el.innerHTML = `
          Available Experience: ${xp}<br>
          Current Apples: ${window.currentPokemon?.Apples ?? 0}
        `;
    }

    function updateMoneyUI(apples) {
        const el = document.querySelector(".experience");
        if (!el) return;

        el.innerHTML = `
          Available Experience: ${window.currentPokemon?.ExperiencePoints ?? 0}<br>
          Current Apples: ${apples}
        `;
    }

    function updateMovesUI(moves) {
        const container = document.querySelector(".moves");
        if (!container) return;

        container.innerHTML = moves.map(renderMove).join("");
    }

    function updateBagUI(bag) {
      const bagContainer = document.getElementById("bagContainer");
      if (!bagContainer) return;

      const header = bagContainer.querySelector(".bag-header");
      const list = bagContainer.querySelector(".bag-content");

      header.textContent = `Pok√©mon Bag (${bag.items.length} items)`;

      if (!bag.items.length) {
        list.innerHTML = `<li class="bag-card">No items</li>`;
        return;
      }

      list.innerHTML = bag.items.map(item => `
        <li class="bag-card">
          <div class="card-top">
            <div class="card-name-category">
              <strong>${item.name}</strong>
              ${item.itemCategory ? `<span class="item-category">${item.itemCategory}</span>` : ""}
            </div>
            ${item.sellPrice
              ? `<button onclick="sellItem('${item.id}')" class="sell-price equip-btn">
                  Sell for: ${item.sellPrice}‚ÇΩ
                </button>` : ""}
          </div>

          ${item.effect ? `<div class="effect">${item.effect}</div>` : ""}
          ${item.description ? `<hr><div class="description">${item.description}</div>` : ""}

          ${item.isEquipable
            ? `<button class="equip-btn" onclick="equipItem('${item.id}')">Equip</button>`
            : ""}
          ${item.isUsable
            ? `<button class="equip-btn" onclick="useItem('${item.id}')">Use Item</button>`
            : ""}
        </li>
      `).join("");
    }

    function updateHeldItemBadge(item) {
      const typesContainer = document.querySelector(".types");
      if (!typesContainer) return;

      const existing = document.getElementById("heldItemBadge");
      if (existing) existing.remove();

      if (!item) return;

      const badge = document.createElement("div");
      badge.className = "badge";
      badge.id = "heldItemBadge";
      badge.innerHTML = makeTooltip(item.name, item);

      badge.onclick = async () => {
        await fetch(`${BASE_URL}/unequipItem/${GAME_ID}/${POKEMON_GUID}`, {
          method: "POST"
        });
      };

      typesContainer.appendChild(badge);
    }

    async function confirmStatPurchase(statName, currentValue, availableXP) {
      const rule = statCostType[statName];
      if (!rule) return;

      const costFn = statCostRules[rule];
      const cost = costFn(currentValue);
      if (statName == "Primal") {
        Swal.fire({
          toast: true,
          timer: 4000,
          timerProgressBar: true,
          width: 630,
          position: "top-end",
          showConfirmButton: false,
          theme: "dark",
          icon: "error",
          title: `${statName} is not buyable`,
          text: `You cannot buy points in ${statName}, ask your DM on how to get it.`
        });
        return;
      }

      if (availableXP < cost) {
        Swal.fire({
          toast: true,
          timer: 3000,
          timerProgressBar: true,
          width: 500,
          position: "top-end",
          showConfirmButton: false,
          theme: "dark",
          icon: "error",
          title: "Not enough XP",
          text: `You need ${cost} XP to increase ${statName}.`
        });
        return;
      }

      const result = await Swal.fire({
        title: `Increase ${statName}?`,
        html: `
            <div>Current Level: <b>${currentValue}</b></div>
            <div>Cost: <b>${cost} XP</b></div>
            `,
        icon: "question",
        theme: "dark",
        showCancelButton: true,
        confirmButtonText: "Buy",
        cancelButtonText: "Cancel",
        confirmButtonColor: "hotpink"
      });

      if (!result.isConfirmed) return;

      await buyStat(statName, POKEMON_GUID);
    }

    async function buyStat(statName, pokemonGuid) {
      const res = await fetch(`${BASE_URL}/buyStat/${GAME_ID}/${pokemonGuid}`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ stat: statName, pokemonGuid: pokemonGuid })
      });

      const json = await res.json();

      if (!res.ok) {
        Swal.fire("Error", json.message || "Purchase failed", "error");
        return;
      }

      Swal.fire({
        toast: true,
        timer: 3000,
        timerProgressBar: true,
        showConfirmButton: false,
        theme: "dark",
        position: "top-end",
        icon: "success",
        title: `${statName} increased!`,
      });

      loadPokemon(); // re-fetch + re-render
    }

    function makeTooltip(label, data) {
      if (!data) return label;

      return `
        <div class="tooltip">
            ${label}
            <div class="tooltip-content">
            <strong>${data.name}</strong><br><br>
            ${data.description ? `<div>${data.description}</div><br>` : ''}
            ${data.effect ? `<div><em>${data.effect}</em></div>` : ''}
            </div>
        </div>
        `;
    }

    function statCircles(value, max = 5) {
      let out = '<div class="stat-circles">';
      for (let i = 1; i <= max; i++) {
        out += `<div class="circle ${i <= value ? 'filled' : ''}"></div>`;
      }
      out += '</div>';
      return out;
    }

    function renderStatColumn(title, mainValue, stats, experiencePoints) {
      return `
            <div class="stat-column">
                <b data-stat-name="${title}" data-stat-value="${mainValue ?? 0}" data-xp="${experiencePoints ?? 0}">
                    ${title} ${statCircles(mainValue ?? 0)}
                </b>
                ${stats.map(s => `
                    <div class="stat-row" data-stat-name="${s.name}" data-stat-value="${s.value ?? 0}" data-xp="${experiencePoints ?? 0}">
                        <span>${s.name}</span>${statCircles(s.value ?? 0)}
                    </div>
                `).join('')}
            </div>
        `;
    }

    function buildMoveTooltip(move) {
        const lines = [];

        // --- Enum / basic fields ---
        if (move.target) {
            lines.push(`Target: ${move.target}`);
        }

        if (move.priority != null) {
            lines.push(`Priority: ${PRIORITY_LABELS[move.priority] ?? move.priority}`);
        }

        if (move.reducedAccuracy != null) {
            lines.push(`Reduced Accuracy: ${move.reducedAccuracy}`);
        }

        lines.push('----------------------');

        const booleanFlags = [
            ["crit", move.hasCritical],
            ["lethal", move.hasLethal],
            ["block", move.hasBlock],
            ["recoil", move.hasRecoil],
            ["always hit", move.alwaysHitEffect],
            ["always fail", move.alwaysFailEffect],
            ["charge move", move.isChargeMove],
            ["fist based", move.isFistBased],
            ["high crit", move.isHighCrit],
            ["never fail", move.isNeverFail],
            ["healing move", move.isHealingMove],
            ["shield move", move.isShieldMove],
            ["sound based", move.isSoundBased],
            ["switch move", move.isSwitchMove],
            ["requires recharge", move.requiresRecharge],
            ["modified damage", move.hasModifiedDamage]
        ];

        booleanFlags.forEach(([label, value]) => {
            if (value === true) {
                lines.push(`${titleCase(label)}.`);
            }
        });

        if (move.isMultiHit) {
            lines.push(`Multi Hit${move.multiHitCount ? ` (${move.multiHitCount})` : ""}.`);
        }

        if (move.hasWeatherChange && move.weatherChangeTo) {
            lines.push(`Weather Change: ${move.weatherChangeTo}`);
        }

        return lines.join('\n');
    }

    // Helper to title-case labels
    function titleCase(str) {
        return str.replace(/\b\w/g, c => c.toUpperCase());
    }

    function renderMove(m) {
      const accuracy = m.accuracyModifiers?.filter(mod => mod && mod !== "NONE").join(" + ") || "-";
      const damage = [...(m.damageModifiers || []), m.basePower || null]
        .filter(mod => mod && mod !== "NONE")
        .join(" + ") || "-";

      const tooltip = buildMoveTooltip(m)
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&#39;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/\n/g, '&#10;');

      const color = typeColors[m.type] || "#666"; // fallback color

      return `
        <div class="move-card tooltip" title="${tooltip}">
          <div class="move-header">
            <span class="move-name" style="color: ${color}">${m.name}</span>
            <span class="move-type" style="color: ${color}">${m.type || ''}/${m.damageType}</span>
          </div>
          <div>Accuracy: ${accuracy}</div>
          <div>Damage Pool: ${damage}</div>
          <div>Target: ${m.target || '-'}</div> <br>
          <div>Added Effect: ${m.effectText || '-'}</div>
          <div class="move-footer">${m.flavorText || ''}</div>
        </div>
      `;
    }

    function renderBag(pokemonBag) {
      const bag = document.getElementById("bagContainer");
      if (!bag) return;

      const bagSizeMap = {
        size0: 0,
        size5: 5,
        size10: 10,
        size15: 15
      };

      const header = bag.querySelector(".bag-header");
      const list = bag.querySelector(".bag-content");

      // Preserve open state
      bag.classList.toggle("open", isBagOpen);
      
      const currentSize = pokemonBag?.items?.length ?? 0;
      const maxSize = bagSizeMap[pokemonBag.bagSize] ?? 0;
      header.textContent = `Pok√©mon Bag (${currentSize}/${maxSize} items)`;

      if (!pokemonBag.items || pokemonBag.items.length === 0) {
        list.innerHTML = `<li class="bag-card">No items</li>`;
        return;
      }

      list.innerHTML = pokemonBag.items.map(item => `
        <li class="bag-card">
          <div class="card-top">
            <div class="card-name-category">
              <strong>${item.name}</strong>
              ${item.itemCategory ? `<span class="item-category">${item.itemCategory}</span>` : ""}
            </div>

            ${item.sellPrice
              ? `<button class="sell-price equip-btn"
                        onclick="sellItem('${item.id}')">
                  Sell for: ${item.sellPrice}‚ÇΩ
                </button>`
              : ""}
          </div>

          ${item.effect ? `<div class="effect">${item.effect}</div>` : ""}
          ${item.description ? `<hr><div class="description">${item.description}</div>` : ""}

          ${!!item.isUsable
            ? `<button class="equip-btn" onclick="useItem('${item.id}')">Use Item</button>` 
            : ""}

          ${!!item.isEquipable
            ? `<button class="equip-btn" onclick="equipItem('${item.id}')">Equip</button>`
            : ""}
        </li>
      `).join("");
    }

    function renderPokemon(p) {
      const card = document.getElementById('pokemonCard');

      const maxHp = p.BaseHealth + p.Vitality;       // correct max HP
      const hpPct = Math.max(0, Math.min(1, p.Health / maxHp)); // correct percentage
      const maxLethalHp = maxHp
      const lethalHpPct = Math.max(0, Math.min(1, p.LethalHealth / maxLethalHp))

      card.innerHTML = `
        <div class="head">
            <div class="meta" style="flex: 1;">
                <h2>${p.Name} ${p.Level ? 'Lv ' + p.Level : ''}</h2>
                <div class="sub">${p.PrimaryType}${p.SecondaryType ? ' / ' + p.SecondaryType : ''}</div>
            </div>
            <div class="experience" style="margin-left: auto; text-align: right;">
                Available Experience: ${p.ExperiencePoints} <br>
                Current Apples: ${p.Apples}
            </div>
        </div>

        <div class="types">
        ${p.Ability ? `<div class="badge">${makeTooltip(p.Ability.name, p.Ability)}</div>` : ''}
        ${p.Nature ? `<div class="badge">${makeTooltip(p.Nature.name, p.Nature)}</div>` : ''}
        ${p.HeldItem ? `<div class="badge" id="heldItemBadge">${makeTooltip(p.HeldItem.name, p.HeldItem)}</div>` : ''}
        ${p.Garments?.map(g => `<div class="badge">${g}</div>`).join('') || ''}
        </div>

        <div class="hp-bar-container">
            <div class="hp-bar">
            <div class="hp-bar-fill" style="width:${hpPct * 100}%"></div>
            </div>
            <div class="hp-text">${p.Health} / ${p.BaseHealth + p.Vitality} HP ¬∑ ${p.Status || 'Healthy'}</div>
        </div>
            <div class="hp-bar-container">
            <div class="hp-bar">
            <div class="lethal-hp-bar-fill" style="width:${lethalHpPct * 100}%"></div>
            </div>
            <div class="lethal-hp-text"">${p.LethalHealth} / ${p.BaseHealth + p.Vitality} Lethal</div>
        </div>

        <div class="stats">
            <div class="stat-group">
                <div class="stat" data-stat-name="Strength" data-stat-value="${p.Strength}" data-xp="${p.ExperiencePoints}">
                    Strength${statCircles(p.Strength, p.StrengthPotential)}
                </div>
                <div class="stat" data-stat-name="Dexterity" data-stat-value="${p.Dexterity}" data-xp="${p.ExperiencePoints}">
                    Dexterity${statCircles(p.Dexterity, p.Dexteritypotential)}
                </div>
                <div class="stat" data-stat-name="Vitality" data-stat-value="${p.Vitality}" data-xp="${p.ExperiencePoints}">
                    Vitality${statCircles(p.Vitality, p.VitalityPotential)}
                </div>
                <div class="stat" data-stat-name="Special" data-stat-value="${p.Special}" data-xp="${p.ExperiencePoints}">
                    Special${statCircles(p.Special, p.SpecialPotential)}
                </div>
                <div class="stat" data-stat-name="Insight" data-stat-value="${p.Insight}" data-xp="${p.ExperiencePoints}">
                    Insight${statCircles(p.Insight, p.InsightPotential)}
                </div>
            </div>

            <div class="stat-group right">
                <div class="stat" data-stat-name="Will" data-stat-value="${p.Will}" data-xp="${p.ExperiencePoints}">
                    Will${statCircles(p.Will, 10)}
                </div>
                <div class="stat" data-stat-name="Logic" data-stat-value="${p.Logic}" data-xp="${p.ExperiencePoints}">
                    Logic${statCircles(p.Logic)}
                </div>
                <div class="stat" data-stat-name="Instinct" data-stat-value="${p.Instinct}" data-xp="${p.ExperiencePoints}">
                    Instinct${statCircles(p.Instinct)}
                </div>
                <div class="stat" data-stat-name="Primal" data-stat-value="${p.Primal}" data-xp="${p.ExperiencePoints}">
                    Primal${statCircles(p.Primal)}
                </div>
            </div>
        </div> <br>

        <div class="stat-columns">
          ${renderStatColumn('Fight', p.Fight, [
            { name: 'Brawl', value: p.Brawl },
            { name: 'Channel', value: p.Channel },
            { name: 'Clash', value: p.Clash },
            { name: 'Evasion', value: p.Evasion },
          ], p.ExperiencePoints)}

          ${renderStatColumn('Survival', p.Survival, [
            { name: 'Alert', value: p.Alert },
            { name: 'Athletic', value: p.Athletic },
            { name: 'Nature', value: p.Nature },
            { name: 'Stealth', value: p.Stealth },
          ], p.ExperiencePoints)}

          ${renderStatColumn('Contest', p.Contest, [
            { name: 'Allure', value: p.Allure },
            { name: 'Etiquette', value: p.Etiquette },
            { name: 'Intimidate', value: p.Intimidate },
            { name: 'Perform', value: p.Perform },
          ], p.ExperiencePoints)}
        </div>

        <div class="moves">
            ${p.Moves.map(renderMove).join('')}
        </div>

        <div class="bag" id="bagContainer">
          <div class="bag-header"></div>
          <ul class="bag-content"></ul>
        </div>
        `;

        const heldItemBadge = document.getElementById("heldItemBadge");
        
        if (heldItemBadge) {
            heldItemBadge.onclick = async () => {
                const res = await fetch(`${BASE_URL}/unequipItem/${GAME_ID}/${POKEMON_GUID}`, { method: "POST" });
                const data = await res.json();
                console.log(data);

                if (data.success) {
                    loadPokemon()
                    heldItemBadge.remove(); // remove badge since item is unequipped
                  } else {
                    alert(data.error);
                }
            };
        }

        const hpFill = card.querySelector('.hp-bar-fill');
        const hpText = card.querySelector('.hp-text');

        const hpLethalFill = card.querySelector(".lethal-hp-bar-fill");
        const hpLethalText = card.querySelector(".lethal-hp-text");

        // function to update HP bar
        function updateHpBar() {
          const currentHp = Math.max(0, Math.min(maxHp, p.Health ?? maxHp));
          const pct = currentHp / maxHp;

          hpFill.style.width = (pct * 100) + '%';

          if (pct > 0.5) hpFill.style.background = '#28c76f';      // green
          else if (pct > 0.25) hpFill.style.background = 'orange'; // orange
          else hpFill.style.background = 'red';                    // red

          hpText.textContent = `${currentHp} / ${maxHp} HP ¬∑ ${p.Status || 'Healthy'}`;
        }

        function updateLethalHpBar() {
          const currentLehtalHp = Math.max(0, Math.min(maxLethalHp, p.LethalHealth ?? maxLethalHp));
          const pct = currentLehtalHp / maxLethalHp;

          hpLethalFill.style.width = (pct * 100) + '%';

          if (pct >= 0.75 && pct < 0.9) {
              hpLethalFill.style.background = "#ff004c"; // DEAD
          } else if (pct <= 0.9) {
              hpLethalFill.style.background = "#ff004c"; // purple
          } else {
              hpLethalFill.style.background = "#000000"; // purple
          }

          hpLethalText.textContent = `${currentLehtalHp} / ${maxLethalHp} ¬∑ Lethal`;
        }

        // initial render
        updateHpBar();
        updateLethalHpBar();

        // Expose updater if you want to modify HP later
        p._updateHpUI = updateHpBar;
        p._updateLethalHpUi = updateLethalHpBar;

        window.currentPokemonMaxHp = maxHp;
        window.currentPokemon = p;

      card.querySelectorAll('.stat, .stat-row, .stat-column > b').forEach(el => {
        el.addEventListener('click', (e) => {
          e.stopPropagation(); // prevent parent from also triggering
          const target = el.closest('[data-stat-name]');
          if (!target) return;
          const statName = target.dataset.statName;
          const statValue = window.currentPokemon[statName];
          const xp = window.currentPokemon.ExperiencePoints;
          confirmStatPurchase(statName, statValue, xp);
        });
      });
      startPlayerStateStream(POKEMON_GUID, p);
      renderBag(p.Bag || { items: [] });
      setupBagToggle();
    }

    function sellItem(itemId) {
      if (!itemId) return;

      Swal.fire({
        title: "Sell item?",
        text: "This cannot be undone.",
        icon: "warning",
        showCancelButton: true,
        confirmButtonText: "Sell",
        confirmButtonColor: "hotpink",
        theme: "dark"
      }).then(result => {
        if (!result.isConfirmed) return;

        fetch(`${BASE_URL}/sellItem/${GAME_ID}/${POKEMON_GUID}/${itemId}`, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
        })
          .then(res => res.json())
          .then(data => {
            if (data.error) {
              Swal.fire("Error", data.error, "error");
              return;
            }

            Swal.fire({
              toast: true,
              theme: "dark",
              position: "top-end",
              icon: "success",
              title: `Sold for ${data.applesGained} ‚ÇΩ`,
              timer: 3000,
              timerProgressBar: true,
              showConfirmButton: false
            });

            // üîÑ Refresh Pok√©mon card only
            loadPokemon();
          })
          .catch(err => {
            Swal.fire("Request failed", err.toString(), "error");
          });
      });
    }

    function equipItem(itemId) {
      if (!itemId) return;

      fetch(`${BASE_URL}/equipItem/${GAME_ID}/${POKEMON_GUID}/${itemId}`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
      })
        .then(res => res.json())
        .then(data => {
          if (data.error) {
            Swal.fire("Error", data.error, "error");
            return;
          }

          Swal.fire({
            toast: true,
            timer: 3000,
            timerProgressBar: true,
            theme: "dark",
            position: "top-end",
            icon: "success",
            title: "Item equipped!",
            showConfirmButton: false
          });

          loadPokemon();
        })
        .catch(err => {
          Swal.fire("Request failed", err.toString(), "error");
        });
    }

    function useItem(bagItemId) {
        const item = getItemFromBag(bagItemId);

        if (!item || !item.isUsable) return;

        const handler = ITEM_USE_HANDLERS[item.effectKey];

        if (!handler) {
            Swal.fire({
                title: "Cannot Use Item",
                text: "This item cannot be used manually.",
                icon: "warning",
                theme: "dark"
            });
            return;
        }

        handler(item);
    }

    function openHealPoolSwal(item) {
        const remaining = item.effectData.maxPool - item.effectData.unitsUsed;

        if (remaining <= 0) {
            Swal.fire({
                title: "Item Depleted",
                text: "This potion has no healing left.",
                icon: "info",
                theme: "dark"
            });
            return;
        }

        Swal.fire({
            title: `Use ${item.name}`,
            theme: "dark",
            html: `
                <p>Remaining healing: <strong>${remaining}</strong></p>
                <label>Healing Units to Use</label>
                <input id="healAmount" type="number" class="swal2-input"
                      min="1" max="${remaining}" value="1">
                <small>1 unit = 1 HP or 2 Lethal HP</small>
            `,
            showCancelButton: true,
            confirmButtonText: "Use",
            preConfirm: () => {
                const value = Number(document.getElementById("healAmount").value);
                if (value < 1 || value > remaining) {
                    Swal.showValidationMessage("Invalid amount");
                    return false;
                }
                return { units: value };
            }
        }).then(result => {
            if (!result.isConfirmed) return;

            sendUseItemRequest(item.id, result.value);
        });
    }

    function sendUseItemRequest(bagItemId, payload = {}) {
        fetch(`${BASE_URL}/useItem/${GAME_ID}/${bagItemId}`, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(payload)
        })
        .then(res => res.json())
        .then(data => {
            Swal.fire({
                toast: true,
                position: "top-end",
                icon: "success",
                title: "Item Used",
                timer: 2500,
                showConfirmButton: false,
                theme: "dark"
            });

            updatePokemonFromResponse(data);
        })
        .catch(() => {
            Swal.fire("Error", "Failed to use item", "error");
        });
    }

    // Bag collapsible toggle
    function setupBagToggle() {
      const bag = document.getElementById("bagContainer");
      if (!bag) return;

      const header = bag.querySelector(".bag-header");

      header.onclick = () => {
        isBagOpen = !isBagOpen;
        bag.classList.toggle("open", isBagOpen);
      };
    }

    // Call after the page renders the bag
    //setupBagToggle();

    async function loadPokemon() {
      const res = await fetch(`${BASE_URL}/playerData/${GAME_ID}/${POKEMON_GUID}`);
      const json = await res.json();
      renderPokemon(json.data);
    }

    loadPokemon();
  </script>

</body>

</html>