<!doctype html>
<html lang="en">
<style>
/* ---------------------------------------------------------
   GLOBAL SCALING
--------------------------------------------------------- */
:root {
  --card-scale: 0.85; /* player is 1.25 */
  --panel-bg: #363636;
  --card-border: #333;
  --muted: #9aa;
  --accent: hotpink;
}


body {
  font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, Arial;
  margin: 0;
  background: #222121;
  color: hotpink;
  overflow-x: hidden;
  user-select: none;
}

/* ---------------------------------------------------------
   LAYOUT
--------------------------------------------------------- */

header {
  padding: 12px 18px;
  display: flex;
  align-items: center;
  gap: 12px;
  background: var(--panel-bg);
  border-bottom: 2px solid hotpink;
}
header h1 {
  font-size: 1.05rem;
  margin: 0;
}

.wrap {
    width: 100%;
    height: 100%;
  display: grid;
  grid-template-columns: 360px 1fr;
  gap: var(--gap);
  padding: 18px;
  align-items: start;
}

/* ---------------------------------------------------------
   LEFT SIDEBAR
--------------------------------------------------------- */

.selectors {
  background: var(--panel-bg);
  padding: 12px;
  border-radius: 10px;
  border: 1px solid var(--card-border);
  max-height: 78vh;
  overflow: auto;
}
.selectors h2 {
  margin: 0 0 8px 0;
  font-size: 0.95rem;
}

.select-row {
  display: flex;
  gap: 8px;
}

select {
  width: 100%;
  min-height: 220px;
  background: transparent;
  color: inherit;
  border: 1px solid #1f2937;
  border-radius: 6px;
  padding: 8px;
}

.controls {
  display: flex;
  gap: 8px;
  margin-top: 12px;
}

button {
  background: #0b7285;
  border: none;
  padding: 8px 10px;
  border-radius: 8px;
  cursor: pointer;
}
button.ghost {
  background: transparent;
  border: 1px solid #234;
  color: var(--muted);
}

/* ---------------------------------------------------------
   GRID OF POK√âMON CARDS
--------------------------------------------------------- */

.stage {
  background: transparent;
  width: 98.5vw;
}
.stage-controls {
  display: flex;
  gap: 8px;
  align-items: center;
  margin-bottom: 12px;
}

.grid {
  /* display: flex; */
  flex-wrap: wrap;
  gap: 1em;                 /* scales with .poke font-size (em-based inside) */
  align-items: flex-start;  /* ensure items align at top */
}

/* ---------------------------------------------------------
   CARD (MAIN SCALING TARGET)
--------------------------------------------------------- */

.poke {
  font-size: calc(1rem * var(--card-scale));
  background: var(--panel-bg);
  padding: 0.7em; /* tighter than player */
  border-radius: 14px;

  background:
    linear-gradient(var(--panel-bg), var(--panel-bg)) padding-box,
    linear-gradient(to right, black, hotpink) border-box;

  border: 3px solid transparent;
  box-sizing: border-box;

  flex: 1 1 320px; /* two-column friendly */
  max-width: 100%;
  margin-bottom: 15px;
}

.poke:nth-last-child {
    margin-bottom: 0 !important;
}

.poke--narrow {
  max-width: 420px; /* optional: add this class to keep cards readable */
}

.poke .head {
  display: flex;
  gap: 0.6em;
  align-items: center;
}

.poke.collapsed .collapsible {
  display: none;
}

.collapse-toggle {
  background: transparent;
  border: none;
  color: hotpink;
  cursor: pointer;
  font-size: 0.9em;
  padding: 0 6px;
}

.collapse-toggle:hover {
  color: #ff69b4;
}

/* ---------------------------------------------------------
   AVATAR (scales cleanly)
--------------------------------------------------------- */

.avatar {
  width: 3.75em;
  height: 3.75em;
  border-radius: 0.5em;
  font-weight: 700;
  display: flex;
  align-items: center;
  justify-content: center;
}

/* ---------------------------------------------------------
   META
--------------------------------------------------------- */

.meta {
  flex: 1;
}
.meta h3 {
  margin: 0;
  font-size: 1.15em; /* down from player 1.4 */
}

.meta .sub {
  font-size: 0.78em;
  color: var(--muted);
}

/* ---------------------------------------------------------
   TYPES & BADGES
--------------------------------------------------------- */

.types {
  display: flex;
  gap: 0.4em;
  margin-top: 0.5em;
  flex-wrap: wrap;
}

.type,
.badge {
  padding: 0.3em 0.55em;
  font-size: 0.75em;
  border-radius: 0.5em;
  background: #222;
  border: 1px solid #444;
  color: white;
}


/* ---------------------------------------------------------
   STATS AREA
--------------------------------------------------------- */

.bars {
    display: grid;
    grid-template-columns: 0.8fr 0.8fr; /* smaller columns */
    column-gap: 0.5em;
    row-gap: 0.3em;
    width: 60%;
}

.stat {
  background: #222;
  border: 1px solid #444;
  border-radius: 6px;
  padding: 0.35em 0.55em;
  font-size: 0.8em;
}

.stat b {
  display: block;
  margin-bottom: 4px;
}

.stat .val {
  font-variant-numeric: tabular-nums;
}

/* ---------------------------------------------------------
   STAT CIRCLES (scalable)
--------------------------------------------------------- */

.stat-circles {
  display: flex;
  gap: 0.25em;
  cursor: pointer;
}

.stat-circles .circle {
  width: 0.85em;
  height: 0.85em;
  border-radius: 50%;
  background-color: #333;
  border: 1px solid #555;
  transition: background 0.2s;
}

.stat-circles .circle.filled {
  background-color: var(--accent);
}

.stat-columns {
  display: flex;
  gap: 1em;
  margin-top: 1em;
}

.stat-column {
  background: #222;
  border: 1px solid #444;
  border-radius: 6px;
  padding: 0.4em 0.6em;
  font-size: 0.85em;
  flex: 1;
}

.stat-column b {
  display: flex;
  flex-direction: column;
  gap: 0.4em;
  margin-bottom: 4px;
  align-items: center; /* üîë centers circles under title */
}

.stat-row {
  display: flex;
  justify-content: space-between;
  margin-bottom: 4px;
  font-size: 1em;
}

/* ---------------------------------------------------------
   MOVES
--------------------------------------------------------- */

.move-card {
  background: #222;
  border: 1px solid #444 !important;
  border-radius: 8px;
  padding: 0.7em;
  color: white;
}

.move-slot {
  border: 1px solid #444;
  border-radius: 8px;
  background: #222;
  min-width: 0;
}

.move-card:hover {
    background: #2c2c2c;
}

.move-header {
  display: flex;
  justify-content: space-between;
  font-weight: bold;
  margin-bottom: 4px;
}

.move-card .move-name {
    font-size: 14px;
}

.move-footer {
  margin-top: 6px;
  font-style: italic;
  opacity: 0.8;
  font-size: 0.75em;
  border-top: 1px solid #555;
  padding-top: 4px;
}

.move-card .move-right {
    font-size: 12px;
}

.move-name {
  font-size: 0.95em;
}

.move-slot .move-header {
  color: inherit;
}

/* ---------------------------------------------------------
   TOOLTIPS
--------------------------------------------------------- */

.tooltip {
    position: relative;
    display: inline-block;
    cursor: help;
    max-width: 100%;
    width: 100%;
}

.tooltip .tooltip-content {
    visibility: hidden;
    opacity: 0;
    transition: opacity 0.15s ease;
    position: absolute;
    z-index: 20;
    background: #111;
    color: #eee;
    border: 1px solid #444;
    border-radius: 6px;
    padding: 10px;
    font-size: 0.8rem;
    width: 240px;
    top: 120%;
    left: 0;
}

.tooltip:hover .tooltip-content {
    visibility: visible;
    opacity: 1;
}

/* ---------------------------------------------------------
   HEALTH BAR
--------------------------------------------------------- */

.hp-bar-container {
    display: flex;
    align-items: center;
    gap: 0.4em;
    margin-top: 8px;
}

.hp-btn {
    background: #222;
    color: #ccc;
    border: 1px solid #444;
    padding: 0.2em 0.5em;
    border-radius: 4px;
    cursor: pointer;
    font-size: 0.9em;
    user-select: none;
}

.hp-btn:hover {
    background: #333;
}

.hp-bar {
    flex: 1;
    height: 12px;
    background: #222;
    border-radius: 6px;
    overflow: hidden;
    border: 1px solid #444;
    max-width: 85%;
}

.hp-bar-fill {
    height: 100%;
    background: #28c76f; /* healthy green */
    width: 50%; /* default, updated in JS */
    transition: width 0.2s ease;
}

.hp-bar-container span {
    flex: 0 0 120px;   /* ‚Üê pick a width that fits both texts */
    white-space: nowrap;
    text-align: left;
}

/* ---------------------------------------------------------
   SWAL
--------------------------------------------------------- */

.swal2-select {
  height: auto !important;
  min-height: unset !important;
  width: auto !important;
  min-width: unset !important;
}

/* ---------------------------------------------------------
   MISC
--------------------------------------------------------- */

.big {
  display: flex;
  gap: 0.8em;
  align-items: center;
}

footer {
  padding: 12px 18px;
  color: var(--muted);
  font-size: 0.85rem;
}

/* ---------------------------------------------------------
   RESPONSIVE
--------------------------------------------------------- */

.battle-columns {
  display: flex;
  gap: 2rem;
  width: 100%;
}

.battle-column {
  flex: 1;
  min-width: 0;
}

/* When NPCs are hidden, players take full width */
.battle-columns.single-column #playersColumn {
  flex: 1 1 100%;
}

.battle-columns.single-column #npcsColumn {
  display: none;
}

@media (max-width: 900px) {
  .wrap {
    grid-template-columns: 1fr;
    padding: 12px;
  }
  .selectors {
    order: 2;
  }
}

/* BOOTSTRAP GARBO */
/* ===== Container ===== */
.container {
    max-width: 700px;
    margin: 0 auto;
    padding: 1rem;
}

/* ===== Headings ===== */
h1, h2, h3 {
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    margin-bottom: 1rem;
}

/* ===== Form Groups ===== */
.mb-3 {
    margin-bottom: 1rem;
}

/* ===== Labels ===== */
label {
    display: block;
    font-weight: 500;
    margin-bottom: 0.25rem;
}

/* ===== Inputs ===== */
input[type="text"],
input[type="number"],
input[type="select"],
select {
    display: block;
    width: 100%;
    padding: 0.25rem 0.5rem; /* slightly smaller padding */
    font-size: 0.9rem;        /* smaller font size to reduce height */
    line-height: 1.3;
    color: #212529;
    background-clip: padding-box;
    border: 1px solid #ced4da;
    border-radius: 0.25rem;
    box-sizing: border-box;
    transition: border-color 0.15s ease-in-out, box-shadow 0.15s ease-in-out;
}

input:focus,
select:focus {
    border-color: #86b7fe;
    outline: 0;
    box-shadow: 0 0 0 0.25rem rgba(13,110,253,.25);
}

/* ===== Buttons ===== */
.btn {
    display: inline-block;
    font-weight: 400;
    color: #fff;
    text-align: center;
    vertical-align: middle;
    user-select: none;
    background-color: hotpink;
    border: 1px solid lightgray;
    padding: 0.375rem 0.75rem;
    font-size: 0.9rem;
    line-height: 1.5;
    border-radius: 0.25rem;
    cursor: pointer;
    transition: background-color 0.15s ease-in-out, border-color 0.15s ease-in-out;
    text-decoration: none;
}

.btn:hover {
    background-color: #0b5ed7;
    border-color: #0a58ca;
}

.btn:disabled {
    background-color: #6c757d;
    border-color: #6c757d;
    cursor: not-allowed;
}

/* ===== Form Select ===== */
.form-select {
    display: block;
    width: 100%;
    padding: 0.25rem 0.5rem; /* smaller height */
    font-size: 0.9rem;
    line-height: 1.3;
    color: #212529;
    background-color: #fff;
    border: 1px solid #ced4da;
    border-radius: 0.25rem;
    appearance: none;
    background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' fill='%23343a40' viewBox='0 0 16 16'%3E%3Cpath d='M4.646 6.646a.5.5 0 0 1 .708 0L8 9.293l2.646-2.647a.5.5 0 0 1 .708.708l-3 3a.5.5 0 0 1-.708 0l-3-3a.5.5 0 0 1 0-.708z'/%3E%3C/svg%3E");
    background-repeat: no-repeat;
    background-position: right 0.5rem center;
    background-size: 0.8rem 0.8rem;
}

/* ===== Alerts ===== */
.alert {
    position: relative;
    padding: 0.75rem 1.25rem;
    margin-bottom: 1rem;
    border: 1px solid transparent;
    border-radius: 0.25rem;
}

.alert-success {
    color: #0f5132;
    background-color: #d1e7dd;
    border-color: #badbcc;
}

.alert-danger {
    color: #842029;
    background-color: #f8d7da;
    border-color: #f5c2c7;
}

.alert-warning {
    color: #664d03;
    background-color: #fff3cd;
    border-color: #ffecb5;
}

/* ===== SweetAlert Overrides ===== */
.swal2-popup {
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    padding: 2rem;
    border-radius: 0.5rem;
    width: 600px !important;
}

.swal2-title {
    font-weight: 600;
    font-size: 1.25rem;
    margin-bottom: 1rem;
}

/* Inputs and selects inside Swal */
.swal2-html-container input,
.swal2-html-container select {
    margin-bottom: 0.5rem;
}

/* Buttons inside Swal */
.swal2-html-container .btn {
    margin-top: 0.5rem;
    width: 30%;
}

/* Horizontal spacing for multiple buttons */
.swal2-actions .btn {
    width: auto;
    margin: 0 0.25rem;
}

/* Make selects slightly less tall */
.swal2-html-container select {
    padding: 0.25rem 0.5rem;
    font-size: 0.9rem;
    line-height: 1.3;
    border-radius: 0.25rem;
}

/* Optional: make cancel and confirm buttons look distinct */
.swal2-cancel {
    background-color: #6c757d !important;
    border-color: #6c757d !important;
}

.swal2-confirm {
    background-color: #0d6efd !important;
    border-color: #0d6efd !important;
}

.swal2-input {
    color: #aaa !important;
}

.core-stats {
  display: flex;
  gap: 0.5em;
  margin-top: 0.9em;
  flex-wrap: nowrap;
}

.core-stat {
  background: #222;
  border: 1px solid #444;
  border-radius: 6px;
  padding: 0.35em 0.55em;
  font-size: 0.8em;
  display: flex;
  flex-direction: column;
  gap: 0.25em;
}

.core-stat b {
  font-size: 0.75em;
  color: var(--muted);
}

.core-stat .stat-circles {
  justify-content: center;
}

.skill-grid {
  display: grid;
  grid-template-columns: repeat(3, 1fr);
  gap: 10px;
  margin-top: 10px;
}

.skill-panel {
  background: #222;
  border: 1px solid #444;
  border-radius: 8px;
  padding: 6px;
}

.skill-header {
  text-align: center;
  font-weight: bold;
  color: hotpink;
  margin-bottom: 6px;
  font-size: 0.85em;
}

.skill-row {
  display: flex;
  justify-content: space-between;
  align-items: center;
  font-size: 0.75em;
  margin-bottom: 4px;
}

</style>

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Battle ‚Äî Select Pok√©mon</title>
</head>
<body>
  <header>
    <h1>Battle ‚Äî pick participants</h1>
    <div style="margin-left:auto; color:var(--muted)">Front: http://localhost:8000 ¬∑ API: http://localhost:9000</div>
  </header>

  <div class="wrap">
    <aside class="selectors">
      <h2>Available Pok√©mon (your game)</h2>
      <div style="display:flex; gap:8px; margin-bottom:8px">
        <input id="search" placeholder="search name or GUID" style="flex:1;padding:8px;border-radius:6px;border:1px solid #1f2937;background:transparent;color:inherit">
        <button id="refresh">Refresh</button>
      </div>

      <div class="select-row">
        <div style="flex:1;">
          <label style="font-size:0.8rem">Players (non-NPC)</label>
          <select id="players" multiple></select>
        </div>
        <div style="flex:1;">
          <label style="font-size:0.8rem">NPCs</label>
          <select id="npcs" multiple></select>
        </div>
      </div>

      <div class="controls">
        <button id="fetchStats">Fetch stats</button>
        <button id="selectAllPlayers" class="ghost">Select all players</button>
        <button id="selectAllNpcs" class="ghost">Select all NPCs</button>
      </div>

      <div style="margin-top:12px; font-size:0.82rem; color:var(--muted)">
        Tip: hold Ctrl / Cmd to select multiple. Click "Fetch stats" to render selected Pok√©mon on the right.
      </div>
    </aside>

    <main class="stage">
        <div id="initiativePanel"
            style="margin-bottom: 1.5rem; padding: 12px; background: rgba(255,255,255,0.03); border:1px solid #333; border-radius:8px;">
            <div style="display:flex; align-items:center;">
                <h3 style="margin:0;">Initiative Order</h3>
                <button id="autoRollNpcs" class="ghost" style="margin-left:auto;">Start Battle (roll NPCs)</button>
            </div>
            <div id="initiativeList" style="margin-top:8px; display:flex; flex-direction:column; gap:4px;"></div>
        </div>
        <div style="display: flex; width: 100%;" id="actionPanel"></div>
      <div class="stage-controls">
        <div style="font-weight:600">Stage</div>
        <div style="margin-left:8px; color:var(--muted)">Showing <span id="count">0</span> Pok√©mon</div>
        <div style="margin-left:auto; display:flex; gap:8px">
          <button style="display: none;" id="clearStage" class="ghost">Clear</button>
          <button id="zoomIn" class="ghost">Zoom +</button>
          <button style="margin-right: 25%;" id="zoomOut" class="ghost">Zoom -</button>
        </div>
      </div>
        <div id="battleColumns" class="battle-columns">
        <div id="playersColumn" class="battle-column">
            <h3 style="margin-bottom:6px;">Players</h3>
            <div class="grid" id="playersGrid"></div>
        </div>

        <div id="npcsColumn" class="battle-column">
            <h3 style="margin-bottom:6px;">NPCs</h3>
            <div class="grid" id="npcsGrid"></div>
        </div>
        </div>
        </div>
    </main>
  </div>

  <footer>
    Expected API endpoints (configurable inside the script):
    <ul>
      <li><code>GET /api/game/pokemons</code> ‚Äî returns array of all GamePokemon for the connected game, each item should include at least: <code>Guid</code>, <code>name</code>, <code>isNpc</code>, and summary stats.</li>
      <li><code>POST /api/pokemon/batch</code> ‚Äî accepts JSON <code>{ guids: ["GUID1","GUID2", ...] }</code> and returns full GamePokemon objects for the requested GUIDs (used to render detailed cards).</li>
    </ul>
  </footer>
  <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11"></script>
  <script>
    window.GameEvents = new EventTarget();
    // Configuration ‚Äî edit to match your back-end and auth method
    const BASE_URL = "{{ baseUrl }}"
    // If you use cookies/session auth (Flask login), keep credentials: 'include'
    const FETCH_OPTS = { headers: {'Content-Type':'application/json'}};
    const GAME_ID = "{{ gameId }}"
    const ITEM_CATEGORIES = "{{ item_categories }}"
    const SHOP_TIERS = "{{ shop_tiers }}"

    const playersSelect = document.getElementById('players');
    const npcsSelect = document.getElementById('npcs');
    const searchInput = document.getElementById('search');
    const stageGrid = document.getElementById('stageGrid');
    const countEl = document.getElementById('count');


    const TYPE_COLORS = {
        Fire: "#F08030",
        Water: "#6890F0",
        Grass: "#78C850",
        Electric: "#F8D030",
        Ice: "#98D8D8",
        Fighting: "#C03028",
        Poison: "#A040A0",
        Ground: "#E0C068",
        Flying: "#A890F0",
        Psychic: "#F85888",
        Bug: "#A8B820",
        Rock: "#B8A038",
        Ghost: "#705898",
        Dragon: "#7038F8",
        Dark: "#705848",
        Steel: "#B8B8D0",
        Fairy: "#EE99AC",
        Normal: "#A8A878",
    };

    const TYPE_CHART = {
      NORMAL:   { ROCK: 0.5, GHOST: 0, STEEL: 0.5 },
      FIRE:     { FIRE: 0.5, WATER: 0.5, GRASS: 2, ICE: 2, BUG: 2, ROCK: 0.5, DRAGON: 0.5, STEEL: 2 },
      WATER:    { FIRE: 2, WATER: 0.5, GRASS: 0.5, GROUND: 2, ROCK: 2, DRAGON: 0.5 },
      ELECTRIC: { WATER: 2, ELECTRIC: 0.5, GRASS: 0.5, GROUND: 0, FLYING: 2, DRAGON: 0.5 },
      GRASS:    { FIRE: 0.5, WATER: 2, GRASS: 0.5, POISON: 0.5, GROUND: 2, FLYING: 0.5, BUG: 0.5, ROCK: 2, DRAGON: 0.5, STEEL: 0.5 },
      ICE:      { FIRE: 0.5, WATER: 0.5, GRASS: 2, GROUND: 2, FLYING: 2, DRAGON: 2, STEEL: 0.5 },
      FIGHTING: { NORMAL: 2, ICE: 2, ROCK: 2, DARK: 2, STEEL: 2, POISON: 0.5, FLYING: 0.5, PSYCHIC: 0.5, BUG: 0.5, GHOST: 0, FAIRY: 0.5 },
      POISON:   { GRASS: 2, FAIRY: 2, POISON: 0.5, GROUND: 0.5, ROCK: 0.5, GHOST: 0.5, STEEL: 0 },
      GROUND:   { FIRE: 2, ELECTRIC: 2, POISON: 2, ROCK: 2, STEEL: 2, GRASS: 0.5, BUG: 0.5, FLYING: 0 },
      FLYING:   { GRASS: 2, FIGHTING: 2, BUG: 2, ELECTRIC: 0.5, ROCK: 0.5, STEEL: 0.5 },
      PSYCHIC:  { FIGHTING: 2, POISON: 2, PSYCHIC: 0.5, STEEL: 0.5, DARK: 0 },
      BUG:      { GRASS: 2, PSYCHIC: 2, DARK: 2, FIRE: 0.5, FIGHTING: 0.5, POISON: 0.5, FLYING: 0.5, GHOST: 0.5, STEEL: 0.5, FAIRY: 0.5 },
      ROCK:     { FIRE: 2, ICE: 2, FLYING: 2, BUG: 2, FIGHTING: 0.5, GROUND: 0.5, STEEL: 0.5 },
      GHOST:    { PSYCHIC: 2, GHOST: 2, DARK: 0.5, NORMAL: 0 },
      DRAGON:   { DRAGON: 2, STEEL: 0.5, FAIRY: 0 },
      DARK:     { PSYCHIC: 2, GHOST: 2, FIGHTING: 0.5, DARK: 0.5, FAIRY: 0.5 },
      STEEL:    { ICE: 2, ROCK: 2, FAIRY: 2, FIRE: 0.5, WATER: 0.5, ELECTRIC: 0.5, STEEL: 0.5 },
      FAIRY:    { FIGHTING: 2, DRAGON: 2, DARK: 2, FIRE: 0.5, POISON: 0.5, STEEL: 0.5 },
    };

    const PRIORITY_LABELS = {
        n7: "-7",
        n6: "-6",
        n5: "-5",
        n4: "-4",
        n3: "-3",
        n2: "-2",
        n1: "-1",
        n0: "0",
        p1: "+1",
        p2: "+2",
        p3: "+3",
        p4: "+4",
        p5: "+5",
    };

    const TARGET_LABELS = {
        User: "User",
        SingleTeam: "Single Team",
        UserAndAllTeamInRange: "User and Team in Range",
        SingleEnemy: "Single Enemy",
        RandomEnemy: "Random Enemy",
        AllEnemyInRange: "All Enemies in Range",
        Area: "Area",
        Battlefield: "Battlefield",
    };

    let allPokemonCache = []; // cached list from GET /api/game/pokemons
    let zoom = 1;
    let initiativeMap = {}; // guid ‚Üí initiative number
    let allMoves = [];
    let activeMove = null;
    // eslint-disable-next-line
    let items = JSON.parse('{{ items | tojson }}');

    function formatMoveRange(move) {
        if (!move.moveRangeType) return null;

        const base = move.moveRangeType;
        if (!base) return null;

        const range = move.moveGridRange ?? 1;
        return base.replace("X", range);
    }

    function createEffectivenessBadge(multiplier, moveType, target) {
        const badge = document.createElement("div");
        badge.style.fontWeight = "bold";
        badge.style.padding = "2px 6px";
        badge.style.borderRadius = "6px";
        badge.style.background = "#111";
        badge.style.border = "1px solid #444";
        badge.style.width = "fit-content";
        badge.style.alignSelf = "center";

        let label = `${multiplier}√ó`;
        if (multiplier === 0) label = "0√ó";
        else if (multiplier < 1) label = "¬Ω√ó";

        badge.innerHTML = `
            <div class="tooltip">
                ${label}
                <div class="tooltip-content">
                    <strong>${moveType}</strong><br>
                    vs ${target.name}<br><br>
                    <strong>${multiplier}√ó effective</strong>
                </div>
            </div>
        `;

        // color hint
        if (multiplier === 0) badge.style.color = "#999";
        else if (multiplier < 1) badge.style.color = "#f5c04f";
        else if (multiplier > 1) badge.style.color = "#28c76f";

        return badge;
    }

    function clearEffectivenessBadges() {
        document.querySelectorAll(".poke").forEach(card => {
            if (card._effectivenessShown) {
                card._effectivenessShown.remove();
                card._effectivenessShown = null;
            }
        });
    }

    function titleCase(str) {
        return str
            .replace(/([A-Z])/g, " $1")
            .replace(/^./, s => s.toUpperCase())
            .trim();
    }

    function getTypeMultiplier(moveType, targetTypes) {
        let multiplier = 1;

        targetTypes.forEach(t => {
            const chart = TYPE_CHART[moveType];
            if (chart && chart[t] !== undefined) {
                multiplier *= chart[t];
            }
        });

        return multiplier;
    }

    async function handleMoveDrop(dragData, target) {
        const {move, sourceGuid} = dragData
        const attacker = currentPokesOnField.find(p => p.guid === sourceGuid)

        if (!attacker) {
            console.warn("Attacker not found for STAB calculation", sourceGuid);
            return;
        }

        const targetTypes = [
            target.primaryType,
            target.secondaryType
        ].filter(Boolean);

        const multiplier = getTypeMultiplier(move.type, targetTypes);

        const { value: accuracy } = await Swal.fire({
            title: "Accuracy Rolls",
            input: "number",
            inputLabel: "Successful accuracy rolls",
            inputAttributes: { min: 0 },
            showCancelButton: true
        });

        if (!accuracy || accuracy < 1) {
          Swal.fire({
            toast: true,
            theme: "dark",
            title: "Attack missed",
            position: "top-end",
            icon: "error",
            showConfirmButton: false,
            timer: 3000,
            timerProgressBar: true,
          });
          return
        }


        const critThreshold = move.isHighCrit ? 4 : 5;
        const isCrit = accuracy >= critThreshold;

        const { value: damageRolls } = await Swal.fire({
            title: "Damage Rolls",
            input: "number",
            inputLabel: "Successful damage rolls",
            inputAttributes: { min: 0 },
            showCancelButton: true
        });

        if (!damageRolls) return;

        applyDamage(attacker, target, move, damageRolls, multiplier, isCrit);
    }

    function updateHealthOnServer(target) {
        fetch(`${BASE_URL}/updateHealth`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                gameId: GAME_ID,
                guid: target.guid,
                health: target.health
            })
        })
        .then(response => response.json())
        .then(data => console.log('Health update successful:', data))
        .catch(error => console.error('Error updating health:', error));
    }

    function updateLethalHealthOnServer(target) {
        fetch(`${BASE_URL}/updateLethalHealth`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                gameId: GAME_ID,
                guid: target.guid,
                lethalHealth: target.lethal
            })
        })
        .then(response => response.json())
        .then(data => console.log('Health update successful:', data))
        .catch(error => console.error('Error updating health:', error));
    }

    function hasSTAB(attacker, move) {
        if (!move || !move.type) return false;

        // Status moves do not get STAB
        if (move.damageType?.toLowerCase() === "status") return false;

        const moveType = move.type.toLowerCase();

        return (
            attacker.primaryType?.toLowerCase() === moveType ||
            attacker.secondaryType?.toLowerCase() === moveType
        );
    }

    function applyDamage(attacker, target, move, rolls, multiplier, isCrit) {
        let damage = Number(rolls);

        if (multiplier === 0) damage = 0;
        else if (multiplier === 0.25) damage -= 2;
        else if (multiplier === 0.5) damage -= 1;
        else if (multiplier === 2) damage = Number(damage) + 1;
        else if (multiplier === 4) damage = Number(damage) + 2;

        if (isCrit) damage += 1;

        if (hasSTAB(attacker, move))
            damage += 1

        damage = Math.max(0, damage);

        // Apply damage locally
        target.applyDamage(damage);

        // Update backend
        updateHealthOnServer(target);

        Swal.fire({
            toast: true,
            theme: "dark",
            position: "top-end",
            title: "Damage Applied",
            showConfirmButton: false,
            timer: 3000,
            timerProgressBar: true,
            text: `${target.name} took ${damage} damage`,
            icon: damage > 0 ? "success" : "info"
        });
    }

    async function loadAllMoves() {
        const res = await fetch(`${BASE_URL}/moveManipulation`);
        const data = await res.json();
        allMoves = data.moves; // [{id, name, type}]
    }

    function createMoveSlot(pokemon, move, slotIndex) {
        const card = document.createElement("div");
        card.className = "move-card";

        if (move) {
            const typeColor = TYPE_COLORS[move.type] || "#aaa";
            card.style.borderColor = typeColor;
            // card.style.boxShadow = `0 0 0 1px ${typeColor} inset`;
            
            card.innerHTML = renderMoveCard(move);
            card.draggable = true;

            card.addEventListener("dragstart", e => {
                activeMove = move;

                e.dataTransfer.setData("moveData", JSON.stringify({
                    sourceGuid: pokemon.guid,
                    move: move
                }));
            });

        } else {
            card.innerHTML = `
                <div class="empty-move-placeholder">
                    Empty Move Slot
                </div>
            `;
        }

        // Clicking still edits the move
        card.onclick = () => openMovePicker(pokemon, slotIndex);

        return card;
    }

    function openMovePicker(pokemon, replaceIndex) {
        const options = {};
        allMoves.forEach(m => {
            options[m.id] = `${m.name} (${m.type})`;
        });

        Swal.fire({
            title: `Select move for ${pokemon.name}`,
            theme: "dark",
            input: "select",
            inputOptions: options,
            inputPlaceholder: "Choose a move",
            showCancelButton: true,
            confirmButtonText: "Assign Move",
        }).then(async result => {
            if (!result.isConfirmed) return;

            const moveId = result.value;

            const res = await fetch(`${BASE_URL}/moveManipulation`, {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({
                    Guid: pokemon.guid,
                    MoveId: moveId,
                    ReplaceIndex: replaceIndex
                })
            });

            const data = await res.json();

            if (!res.ok) {
                Swal.fire("Error", data.error || "Failed to assign move", "error");
                return;
            }

            // Update local state
            const selectedMove = allMoves.find(m => m.id == moveId);
            pokemon.Moves[data.slot] = data.move;

            // Re-render stage
            renderStage(currentPokesOnField);
        });
    }

    function makeTooltip(label, data) {
        if (!data) return label;

        return `
            <div class="tooltip">
                ${label}
                <div class="tooltip-content">
                    <strong>${data.name}</strong><br><br>
                    ${data.description ? `<div>${data.description}</div><br>` : ""}
                    ${data.effect ? `<div><em>${data.effect}</em></div>` : ""}
                    ----------------------------
                    ${data.flavorText ? `<div style="color:#9aa"><i>"${data.flavorText}"</i></div>` : ""}
                </div>
            </div>
        `;
    }

    function computeInitiative(poke) {
        // Change this rule if you want different initiative logic
        let d6 = Math.floor(Math.random() * (7 - 1)) + 1
        return d6 + poke.dexterity + poke.survival ?? 0;
    }

    function updateInitiativePanel(pokes) {
        const listEl = document.getElementById("initiativeList");
        listEl.innerHTML = "";

        const filled = pokes.filter(p => initiativeMap[p.guid] !== undefined);

        const sorted = filled.sort((a,b) => initiativeMap[b.guid] - initiativeMap[a.guid]);

        sorted.forEach((p, idx) => {
            const row = document.createElement('div');
            row.style.display = "flex";
            row.style.justifyContent = "space-between";
            row.style.padding = "4px 8px";
            row.style.background = "rgba(255,255,255,0.02)";
            row.style.borderRadius = "6px";

            // Determine name color
            let nameColor = "inherit";
            if (!p.isNpc && p.playerColor && p.playerColor !== "None") {
                nameColor = p.playerColor;  // use frontend-supplied color
            }

            row.innerHTML = `
            <div>
                <strong>${idx + 1}.</strong>
                <span style="color:${nameColor}">${p.name}</span>
            </div>
            <div style="color:var(--muted)">
                Init: ${initiativeMap[p.guid]}
                ¬∑ Dist: ${p.distance ?? 0}
            </div>
            `;

            listEl.appendChild(row);
        });
    }

    function renderInitiative(pokes) {
        const listEl = document.getElementById('initiativeList');
        listEl.innerHTML = '';

        // Sort highest ‚Üí lowest
        const sorted = [...pokes].sort((a,b) => computeInitiative(b) - computeInitiative(a));

        sorted.forEach((p, index) => {
            const row = document.createElement('div');
            row.style.padding = "4px 8px";
            row.style.borderRadius = "6px";
            row.style.background = "rgba(255,255,255,0.02)";
            row.style.display = "flex";
            row.style.justifyContent = "space-between";

            row.innerHTML = `
                <div><strong>${index+1}.</strong> ${p.name}</div>
                <div style="color:var(--muted)">
                    ${p.isNpc ? 'NPC' : 'Player'}
                </div>
            `;

            listEl.appendChild(row);
        });
    }

    document.getElementById("autoRollNpcs").addEventListener("click", () => {
        // roll NPCs with missing initiative
        for (const p of currentPokesOnField) {
            if (p.isNpc && initiativeMap[p.guid] === undefined) {
                const roll = Math.floor(Math.random()*6)+1;
                const total = roll + (p.dexterity ?? 0) + (p.survival ?? 0);
                initiativeMap[p.guid] = total;
            }
        }
        updateInitiativePanel(currentPokesOnField);
    });


    function normalizePokemon(p){
        return {
            guid: p.Guid ?? p.guid,
            name: p.Name ?? p.name,
            isNpc: p.IsNpc ?? p.isNpc,

            level: p.Level ?? p.level,
            status: p.Status ?? p.status,
            primaryType: p.PrimaryType ?? p.primaryType,
            secondaryType: p.SecondaryType ?? p.secondaryType,
            heldItem: p.HeldItem ?? p.heldItem,

            health: p.Health ?? p.health,
            baseHealth: p.BaseHealth ?? p.baseHealth,

            ability: p.Ability ?? p.ability ?? null,
            nature: p.Nature ?? p.nature ?? null,

            // Stats
            strength: p.Strength ?? p.strength,
            dexterity: p.Dexterity ?? p.dexterity,
            vitality: p.Vitality ?? p.vitality,
            special: p.Special ?? p.special,
            insight: p.Insight ?? p.insight,

            strengthPotential: p.StrengthPotential ?? p.strengthPotential ?? 0,
            dexterityPotential: p.DexterityPotential ?? p.dexterityPotential ?? 0,
            vitalityPotential: p.VitalityPotential ?? p.vitalityPotential ?? 0,
            specialPotential: p.SpecialPotential ?? p.specialPotential ?? 0,
            insightPotential: p.InsightPotential ?? p.insightPotential ?? 0,

            // Skills
            fight: p.Fight ?? p.fight,
            survival: p.Survival ?? p.survival,
            contest: p.Contest ?? p.contest,
            brawl: p.Brawl ?? p.brawl,
            evasion: p.Evasion ?? p.evasion,
            channel: p.Channel ?? p.channel,
            clash: p.Clash ?? p.clash,
            alert: p.Alert ?? p.alert,
            athletic: p.Athletic ?? p.athletic,
            natureStat: p.NatureStat ?? p.natureStat,
            stealth: p.Stealth ?? p.stealth,
            perform: p.Perform ?? p.perform,

            playerColor: p.PlayerColor ?? p.playerColor ?? null,

            Bag: p.Bag ?? p.bag ?? [],
            Moves: p.Moves ?? p.moves ?? [],
            MoveIds: p.MoveIds ?? p.moveIds ?? [],
        };
    }

    function createStatCircles(statName, value, potential) {
    const container = document.createElement('div');
    container.className = 'stat-circles';

    for (let i = 1; i <= potential; i++) {
        const c = document.createElement('div');
        c.className = 'circle' + (i <= value ? ' filled' : '');
        c.addEventListener('click', () => {
        if (i <= value) {
            value = i - 1; // decrease
        } else {
            value = i; // increase
        }
        // update circles visually
        Array.from(container.children).forEach((circle, idx) => {
            circle.classList.toggle('filled', idx < value);
        });
        });
        container.appendChild(c);
    }

    return container;
    }

    async function loadAll(){
      try{
          loadAllMoves();
          const res = await fetch(`${BASE_URL}/PullAllPokemon/{{ gameId }}`, {...FETCH_OPTS, method:'GET'});
          if(!res.ok) throw new Error('Failed to load pokemons');

          const raw = await res.json();
          const list = raw.data || raw.pokemons || raw || [];

          // Normalize keys so the rest of the UI works
          allPokemonCache = list.map(p => normalizePokemon(p));

          renderSelects(allPokemonCache);
      }catch(e){
          console.error(e);
          alert('Error loading pokemons ‚Äî open console for details');
      }
    }

    function renderSelects(list){
    playersSelect.innerHTML = '';
    npcsSelect.innerHTML = '';

    const q = (searchInput.value || '').trim().toLowerCase();

    list.forEach(p => {
        const guid = p.guid;  // ALWAYS lowercase, since our normalizePokemon guarantees it

        if (!guid) return; // safety

        if (q && !p.name.toLowerCase().includes(q) && !guid.toLowerCase().includes(q)) {
        return;
        }

        const opt = document.createElement('option');
        opt.value = guid;
        opt.textContent = `${p.name} (${guid})`;
        opt.dataset.obj = JSON.stringify(p);

        if (p.isNpc) npcsSelect.appendChild(opt);
        else playersSelect.appendChild(opt);
    });
    }

    function getSelectedGuids(){
      const a = Array.from(playersSelect.selectedOptions).map(o=>o.value);
      const b = Array.from(npcsSelect.selectedOptions).map(o=>o.value);
      return {players:a,npcs:b,all:a.concat(b)};
    }

    async function fetchSelectedAndRender(){
        const guids = getSelectedGuids().all;
        if(!guids.length){ alert('No Pok√©mon selected'); return; }

        try{
            const res = await fetch(`${BASE_URL}/battleData`, {
            ...FETCH_OPTS,
            method:'POST',
            body: JSON.stringify({ guids, gameId: GAME_ID })
            });

            if(!res.ok){
            console.warn("Batch endpoint missing, falling back to cached list");
            const selected = allPokemonCache.filter(p => guids.includes(p.guid));
            return renderStage(selected);
            }

            const raw = await res.json();
            const list = raw.data || raw.pokemons || [];

            // Normalize keys just like loadAll()
            const pokes = list.map(p => normalizePokemon(p));

            renderStage(pokes);
        }catch(err){
            console.error(err);
            alert('Error fetching selected Pok√©mon details ‚Äî check console');
        }
    }

    function renderStage(pokes){
        currentPokesOnField = pokes;
        const playersGrid = document.getElementById('playersGrid');
        const npcsGrid   = document.getElementById('npcsGrid');
        const battleCols  = document.getElementById('battleColumns');

        playersGrid.innerHTML = '';
        npcsGrid.innerHTML   = '';

        const hasPlayers = pokes.some(p => !p.isNpc);
        const hasNpcs    = pokes.some(p => p.isNpc);

        if (hasPlayers && !hasNpcs)
            battleCols.classList.add("single-column");
        else
            battleCols.classList.remove("single-column");

        renderInitiative(pokes);

        pokes.forEach(p => {
            // create card container
            const card = document.createElement('div'); 
            card.className = 'poke';
            card.draggable = true;

            // head (+ meta)
            const head = document.createElement('div'); 
            head.className='head'; 
            head.style.marginLeft = "1%";

            const meta = document.createElement('div'); 
            meta.className='meta';

            const titleRow = document.createElement('div');
            titleRow.style.display = "flex";
            titleRow.style.alignItems = "center";
            titleRow.style.justifyContent = "flex-start";

            const title = document.createElement('h3');
            title.style.margin = "0";
            title.textContent = `${p.name} ${p.level ? 'Lv ' + p.level : ''}`;
            titleRow.appendChild(title);

            // spacer pushes everything after it to the right
            const spacer = document.createElement("div");
            spacer.style.flex = "1";
            titleRow.appendChild(spacer);

            // right-side controls
            const titleControls = document.createElement("div");
            titleControls.style.display = "flex";
            titleControls.style.alignItems = "center";
            titleControls.style.gap = "4px";
            meta.appendChild(titleRow);

            const collapseBtn = document.createElement("button");
            collapseBtn.className = "collapse-toggle";
            collapseBtn.textContent = "‚ñº";

            collapseBtn.onclick = (e) => {
                e.stopPropagation();
                card.classList.toggle("collapsed");
                collapseBtn.textContent = card.classList.contains("collapsed") ? "‚ñ∂" : "‚ñº";
            };

            // Toggle button
            const lethalToggle = document.createElement("button");
            lethalToggle.textContent = "Show Lethal HP";
            lethalToggle.style.marginTop = "4px";
            lethalToggle.style.padding = "3px 6px";
            lethalToggle.classList.add("btn")
            lethalToggle.classList.add("btn-submit")

            titleControls.appendChild(lethalToggle);
            titleControls.appendChild(collapseBtn);
            titleRow.appendChild(titleControls);

            head.style.cursor = "pointer";
            head.onclick = (e) => {
                if (e.target.closest("button")) return; // don't double-trigger
                collapseBtn.click();
            };


            const sub = document.createElement('div');
            sub.className='sub';
            sub.innerHTML = `GUID: ${p.guid || p.Guid} ¬∑ ${p.status || 'Healthy'}`;
            meta.appendChild(sub);
            head.appendChild(meta);
            card.appendChild(head);

            // types and item
            const tline = document.createElement('div'); 
            tline.className='types';
            tline.style.display = "flex";
            tline.style.alignItems = "center";
            tline.style.gap = "6px";

            if(p.primaryType) { 
                const t = document.createElement('div'); 
                t.className='type'; 
                t.textContent = p.primaryType; 
                tline.appendChild(t); 
            }

            if(p.secondaryType) { 
                const t = document.createElement('div'); 
                t.className='type'; 
                t.textContent = p.secondaryType; 
                tline.appendChild(t); 
            }

            const effectivenessSlot = document.createElement("div");
            effectivenessSlot.className = "effectiveness-slot";
            effectivenessSlot.style.marginLeft = "6px";
            effectivenessSlot.style.width = "33.2px"
            tline.appendChild(effectivenessSlot);

            // store reference for later
            card._effectivenessSlot = effectivenessSlot;

            if (p.heldItem) {
                const it = document.createElement('div');
                it.className = 'badge';
                it.innerHTML = makeTooltip("Item: " + p.heldItem.name, p.heldItem);
                tline.appendChild(it);
            }

            if (p.ability) {
                const ab = document.createElement('div');
                ab.className = "badge";
                ab.innerHTML = makeTooltip("Ability: " + p.ability.name, p.ability);
                tline.appendChild(ab);
            }

            if (p.nature) {
                const nt = document.createElement('div');
                nt.className = "badge";
                nt.innerHTML = makeTooltip("Nature: " + p.nature.name, p.nature);
                tline.appendChild(nt);
            }

            card.appendChild(tline);

            // HEALTH BAR SYSTEM
            const maxHp = (p.baseHealth ?? 0) + (p.vitality ?? 0);
            let currentHp = p.health ?? maxHp;

            if (p.lethal == null) p.lethal = 0;
            let currentLethal = p.lethal;

            const hpContainer = document.createElement('div');
            hpContainer.className = "hp-bar-container";

            const minusBtn = document.createElement('div');
            minusBtn.className = "hp-btn";
            minusBtn.textContent = "‚Äì";

            const plusBtn = document.createElement('div');
            plusBtn.className = "hp-btn";
            plusBtn.textContent = "+";

            const bar = document.createElement('div');
            bar.className = "hp-bar";

            const fill = document.createElement('div');
            fill.className = "hp-bar-fill";
            bar.appendChild(fill);

            const hpText = document.createElement('span');
            hpText.style.marginLeft = "0.5em";
            hpText.style.color = "var(--muted)";

            function updateHpBar() {
                currentHp = Math.max(0, Math.min(maxHp, p.health ?? maxHp));

                const pct = currentHp / maxHp;
                fill.style.width = (pct * 100) + "%";

                if (pct > 0.5) fill.style.background = "#28c76f";
                else if (pct > 0.25) fill.style.background = "#f5c04f";
                else fill.style.background = "#ea5455";

                hpText.textContent = ` ${currentHp}/${maxHp} ¬∑ ${p.status || 'Healthy'}`;
            }
            
            // * set refernce to pokemon's own ui updater
            p._updateHpUI = updateHpBar;

            p.applyDamage = (amount) => {
                p.health = Math.max(0, (p.health ?? maxHp) - amount);
                updateHpBar();
                updateHealthOnServer(p)
            };

            minusBtn.onclick = () => {
                p.health = Math.max(0, (p.health ?? maxHp) - 1);
                updateHpBar();
                updateHealthOnServer(p)
            };

            plusBtn.onclick = () => {
                p.health = Math.min(maxHp, (p.health ?? maxHp) + 1);
                updateHpBar();
                updateHealthOnServer(p)
            };

            // Initial render
            updateHpBar();

            hpContainer.appendChild(minusBtn);
            hpContainer.appendChild(bar);
            hpContainer.appendChild(plusBtn);
            hpContainer.appendChild(hpText);

            card.appendChild(hpContainer);

            // ========== LETHAL HP ========== //

            // Lethal bar container
            const lethalContainer = document.createElement("div");
            lethalContainer.className = "hp-bar-container";
            lethalContainer.style.display = "none"; // hidden by default

            // Lethal buttons
            const lethalMinus = document.createElement("div");
            lethalMinus.className = "hp-btn";
            lethalMinus.textContent = "‚Äì";

            const lethalPlus = document.createElement("div");
            lethalPlus.className = "hp-btn";
            lethalPlus.textContent = "+";

            // Lethal bar
            const lethalBar = document.createElement("div");
            lethalBar.className = "hp-bar";

            const lethalFill = document.createElement("div");
            lethalFill.className = "hp-bar-fill";

            lethalBar.appendChild(lethalFill);

            // Lethal text
            const lethalText = document.createElement("span");
            lethalText.style.marginLeft = "0.5em";
            lethalText.style.color = "var(--muted)";

            function updateLethalBar() {
                const pct = Math.max(0, Math.min(1, currentLethal / maxHp));
                lethalFill.style.width = (pct * 100) + "%";

                // Lethal bar color (purple gradient)
                if (pct === 1) {
                    lethalFill.style.background = "#ff004c"; // DEAD
                } else {
                    lethalFill.style.background = "#8e44ad"; // purple
                }

                lethalText.textContent = `${currentLethal}/${maxHp} ¬∑ Lethal`;
            }
            p._updateLethalUI = updateLethalBar;

            // Lethal button logic
            lethalMinus.onclick = () => {
                currentLethal = Math.max(0, currentLethal - 1);
                p.lethal = currentLethal;
                updateLethalHealthOnServer(p)
                updateLethalBar();
            };

            lethalPlus.onclick = () => {
                currentLethal = Math.min(maxHp, currentLethal + 1);
                p.lethal = currentLethal;
                updateLethalHealthOnServer(p)
                updateLethalBar();
            };

            updateLethalBar();

            // Assemble lethal bar
            lethalContainer.appendChild(lethalMinus);
            lethalContainer.appendChild(lethalBar);
            lethalContainer.appendChild(lethalPlus);
            lethalContainer.appendChild(lethalText);

            // Toggle logic
            lethalToggle.onclick = () => {
                if (lethalContainer.style.display === "none") {
                    lethalContainer.style.display = "flex";
                    lethalToggle.textContent = "Hide Lethal HP";
                } else {
                    lethalContainer.style.display = "none";
                    lethalToggle.textContent = "Show Lethal HP";
                }
            };

            card.appendChild(lethalContainer);

            const collapsible = document.createElement("div");
            collapsible.className = "collapsible";

            const coreStats = document.createElement("div");
            coreStats.className = "core-stats";

            const stats = [
            ["STR", p.strength, p.strengthPotential],
            ["DEX", p.dexterity, p.dexterityPotential],
            ["VIT", p.vitality, p.vitalityPotential],
            ["INS", p.insight, p.insightPotential],
            ["SPE", p.special, p.specialPotential],
            ];

            stats.forEach(([label, value, potential]) => {
            const stat = document.createElement("div");
            stat.className = "core-stat";

            const title = document.createElement("b");
            title.textContent = label;

            stat.appendChild(title);
            stat.appendChild(createStatCircles(label, value ?? 0, potential ?? 0));

            coreStats.appendChild(stat);
            });

            collapsible.appendChild(coreStats);

            const statColumns = document.createElement("div");
            statColumns.className = "stat-columns";

            statColumns.appendChild(
                renderStatColumnBattle("Fight", p.fight, [
                    { name: "Brawl", value: p.brawl },
                    { name: "Channel", value: p.channel },
                    { name: "Clash", value: p.clash },
                    { name: "Evasion", value: p.evasion },
                ])
            );

            statColumns.appendChild(
                renderStatColumnBattle("Survival", p.survival, [
                    { name: "Alert", value: p.alert },
                    { name: "Athletic", value: p.athletic },
                    { name: "Nature", value: p.nature },
                    { name: "Stealth", value: p.stealth },
                ])
            );

            statColumns.appendChild(
                renderStatColumnBattle("Contest", p.contest, [
                    { name: "Allure", value: p.allure },
                    { name: "Etiquette", value: p.etiquette },
                    { name: "Intimidate", value: p.intimidate },
                    { name: "Perform", value: p.perform },
                ])
            );

            collapsible.appendChild(statColumns);

            // -------- MOVES --------
            if (p.Moves && Array.isArray(p.Moves)) {
                const movesWrapper = document.createElement("div");
                movesWrapper.style.display = "grid";
                movesWrapper.style.gridTemplateColumns = "1fr 1fr";
                movesWrapper.style.gap = "10px";
                movesWrapper.style.marginTop = "10px";

                for (let slot = 0; slot < 4; slot++) {
                    const move = p.Moves[slot] || null;
                    const moveCard = createMoveSlot(p, move, slot);
                    movesWrapper.appendChild(moveCard);
                }

            collapsible.appendChild(movesWrapper);
            }

            // INITIATIVE INPUT AREA (players + NPCs)
            const initBox = document.createElement('div');
            initBox.style.marginTop = "10px";
            initBox.style.padding = "6px";
            initBox.style.background = "rgba(255,255,255,0.04)";
            initBox.style.border = "1px solid var(--card-border)";
            initBox.style.borderRadius = "8px";

            initBox.innerHTML = `
            <div style="display:flex; gap:6px; align-items:center;">
                <div style="flex:1;">
                <label style="font-size:0.75rem; color:var(--muted)">Initiative</label>
                <input type="number" class="initiative-input" />
                </div>
                <div style="width:90px;">
                <label style="font-size:0.75rem; color:var(--muted)">Distance</label>
                <input type="number" class="distance-input" />
                </div>
            </div>
            `;

            const initInput = initBox.querySelector(".initiative-input");
            const distInput = initBox.querySelector(".distance-input");
            initInput.value = initiativeMap[p.guid] ?? "";
            distInput.value = p.distance ?? 0;

            initInput.addEventListener("input", () => {
                initiativeMap[p.guid] = Number(initInput.value);
                updateInitiativePanel(pokes);
            });
            distInput.addEventListener("input", () => {
                let value = Number(distInput.value || 0)
                console.log(p.isNpc)
                p.distance = p.isNpc ? Math.abs(value) : -Math.abs(value);

                updateInitiativePanel(pokes);
            })

            card.addEventListener("dragover", e => {
                e.preventDefault();

                if (!activeMove) return;

                const targetTypes = [p.primaryType, p.secondaryType].filter(Boolean);
                const multiplier = getTypeMultiplier(activeMove.type, targetTypes);

                if (card._effectivenessShown) return;

                const badge = createEffectivenessBadge(multiplier, activeMove.type, p);
                card._effectivenessSlot.appendChild(badge);
                card._effectivenessShown = badge;
            });

            card.addEventListener("dragleave", () => {
                if (card._effectivenessShown) {
                    card._effectivenessShown.remove();
                    card._effectivenessShown = null;
                }
            });

            card.addEventListener("drop", e => {
                e.preventDefault();
                activeMove = null;
                clearEffectivenessBadges();

                const data = JSON.parse(e.dataTransfer.getData("moveData"));
                handleMoveDrop(data, p);
            });


            collapsible.appendChild(initBox);

            card.appendChild(collapsible);
            if (p.isNpc) npcsGrid.appendChild(card);
            else playersGrid.appendChild(card);

            updateInitiativePanel(pokes);
        });

        countEl.textContent = pokes.length;
        document.documentElement.style.setProperty('--scale', zoom);
    }

    function renderStatColumnBattle(title, statValue, skills, max = 5) {
        const col = document.createElement("div");
        col.className = "stat-column";

        const header = document.createElement("b");
        header.textContent = title;

        // main stat circles (CENTERED UNDER TITLE)
        const mainCircles = createStatCircles(title.toLowerCase(), statValue ?? 0, max);
        mainCircles.style.justifyContent = "center";

        header.appendChild(mainCircles);
        col.appendChild(header);

        skills.forEach(skill => {
            const row = document.createElement("div");
            row.className = "stat-row";

            const label = document.createElement("span");
            label.textContent = skill.name;

            const circles = createStatCircles(
                skill.name.toLowerCase(),
                skill.value ?? 0,
                max
            );

            row.appendChild(label);
            row.appendChild(circles);
            col.appendChild(row);
        });

        return col;
    }

    function renderMoveCard(move) {
        const rangeText = formatMoveRange(move)
        console.log(move.moveRangeType)
        const accuracyMods =
            move.accuracyModifiers?.filter(m => m && m !== "NONE").join(" + ") || "-";

        const damageMods = [];

        if (move.damageModifiers?.length) {
            damageMods.push(
                move.damageModifiers.filter(m => m && m !== "NONE").join(" + ")
            );
        }

        if (move.basePower) {
            damageMods.push(move.basePower);
        }

        const damagePool = damageMods.join(" + ") || "-";

        const typeKey = move.type
            ? move.type.charAt(0).toUpperCase() + move.type.slice(1).toLowerCase()
            : null;

        const color = TYPE_COLORS[typeKey] || "#aaa";

        return `
            <div class="tooltip">
                <div class="move-header">
                    <span class="move-name" style="color:${color}">
                        ${move.name}
                    </span>
                    <span class="move-right" style="color:${color}">
                        ${typeKey}/${move.damageType}
                    </span>
                </div>

                <div>Accuracy: ${accuracyMods}</div>
                <div>Damage Pool: ${damagePool}</div> <br>
                <div>Range: ${rangeText}</div> <br>
                <div>Added Effect: ${move.effectText || "-"}</div>

                <div class="move-footer">${move.flavorText || ""}</div>

                <div class="tooltip-content">
                    ${buildTooltip(move).replace(/\n/g, "<br>")}
                </div>
            </div>
        `;
    }

    function buildTooltip(move) {
        const lines = [];

        if (move.priority != null) {
            lines.push(`Priority: ${PRIORITY_LABELS[move.priority] ?? move.priority}`);
        }

        lines.push(`----------------------`)

        // --- Boolean flags (title-style, no "true") ---
        const booleanFlags = [
            ["crit", move.hasCritical],
            ["lethal", move.hasLethal],
            ["block", move.hasBlock],
            ["recoil", move.hasRecoil],
            ["always hit", move.alwaysHitEffect],
            ["always fail", move.alwaysFailEffect],
            ["charge move", move.isChargeMove],
            ["fist based", move.isFistBased],
            ["high crit", move.isHighCrit],
            ["never fail", move.isNeverFail],
            ["healing move", move.isHealingMove],
            ["shield move", move.isShieldMove],
            ["sound based", move.isSoundBased],
            ["switch move", move.isSwitchMove],
            ["requires recharge", move.requiresRecharge],
        ];

        booleanFlags.forEach(([label, value]) => {
            if (value === true) {
                lines.push(`${titleCase(label)}.`);
            }
        });

        // --- Special cases ---
        if (move.isMultiHit) {
            lines.push(`Multi Hit${move.multiHitCount ? ` (${move.multiHitCount})` : ""}.`);
        }

        if (move.hasWeatherChange && move.weatherChangeTo) {
            lines.push(`Weather Change: ${move.weatherChangeTo}`);
        }

        if (move.hasModifiedDamage) {
            lines.push("Modified Damage.");
        }

        return lines.join("\n");
    }

    // UI wired actions
    document.getElementById('refresh').addEventListener('click', loadAll);
    // document.getElementById('fetchStats').addEventListener('click', fetchSelectedAndRender);
    document.getElementById('selectAllPlayers').addEventListener('click', ()=>{ for(let i=0;i<playersSelect.options.length;i++) playersSelect.options[i].selected=true });
    document.getElementById('selectAllNpcs').addEventListener('click', ()=>{ for(let i=0;i<npcsSelect.options.length;i++) npcsSelect.options[i].selected=true });
    document.getElementById('zoomIn').addEventListener('click', () => {
        zoom = Math.min(1.6, zoom + 0.1);
        document.documentElement.style.setProperty('--card-scale', zoom);
    });

    document.getElementById('zoomOut').addEventListener('click', () => {
        zoom = Math.max(0.6, zoom - 0.1);
        document.documentElement.style.setProperty('--card-scale', zoom);
    });

    async function handleFetchStats() {
        document.querySelectorAll('.selectors').forEach(el => {
            el.style.display = 'none';
        });
        globalAddResourceBtn.style.display = "block";
        globalRemoveResourceBtn.style.display = "block";
        genLootItemBtn.style.display = "block";
        toggleShopBtn.style.display = "block";
        targetBtn.style.display = "block";
        document.getElementById("clearStage").style.display = "block";

        fetchSelectedAndRender();
    }

    document.getElementById('fetchStats').addEventListener('click', handleFetchStats);

    document.getElementById('clearStage').addEventListener('click', () => { 
        // Clear grids
        const playersGrid = document.getElementById('playersGrid');
        const npcsGrid = document.getElementById('npcsGrid');

        playersGrid.innerHTML = '';
        npcsGrid.innerHTML = '';

        // Reset count
        countEl.textContent = '0';

        // Reset initiative state
        initiativeMap = {};
        currentPokesOnField = [];

        // Clear initiative UI
        document.getElementById("initiativeList").innerHTML = "";

        // Show selectors again
        document.querySelectorAll('.selectors').forEach(el => {
            el.style.display = '';
        });

        // Hide clear button again
        document.getElementById("clearStage").style.display = "none";
    });

    function openGiveResourcesModal() {
        // Step 1: choose action
        Swal.fire({
            title: "Choose an action",
            showCancelButton: true,
            showConfirmButton: false,
            theme: "dark",
            html: `
                <div style="display:flex; flex-direction:column; gap:10px;">
                    <button id="giveItemBtn" class="swal2-confirm swal2-styled">Give Item</button>
                    <button id="giveXpBtn" class="swal2-confirm swal2-styled">Give XP</button>
                    <button id="giveMoneyBtn" class="swal2-confirm swal2-styled">Give Money</button>
                    <button id="addItem" class="swal2-confirm swal2-styled">Add Item</button>
                    <button id="addMove" class="swal2-confirm swal2-styled">Add Move</button>
                </div>
            `,
            didOpen: () => {
                const popup = Swal.getPopup();
                
                popup.querySelector("#giveItemBtn").addEventListener('click', () => {
                    Swal.close();
                    selectPokemonForItem();
                });
                popup.querySelector("#giveXpBtn").addEventListener('click', () => {
                    Swal.close();
                    selectTargetsForValue("XP");
                });
                popup.querySelector("#giveMoneyBtn").addEventListener('click', () => {
                    Swal.close();
                    selectTargetsForValue("Money");
                });
                popup.querySelector("#addItem").addEventListener('click', () => {
                    Swal.close();
                    openAddItemModal(null);
                });
                popup.querySelector("#addMove").addEventListener('click', () => {
                    Swal.close();
                    openAddMoveModal(null)
                });
            }
        });
    }

    // Step 2a: select Pok√©mon for item
    function selectPokemonForItem() {
        const playerOptions = currentPokesOnField
            .filter(p => !p.isNpc)
            .map(p => `<option value="${p.guid}">${p.name}</option>`)
            .join('');

        const itemOptions = items.map(it => `<option value="${it.id}">${it.name}</option>`).join('');

        Swal.fire({
            title: "Give Item",
            theme: "dark",
            html: `
                <div style="display:flex; flex-direction:column; gap:10px;">
                    <label>Choose Pok√©mon:</label>
                    <select id="selectPokemon" class="swal2-select">
                        ${playerOptions}
                    </select>

                    <label>Choose Item:</label>
                    <select id="selectItem" class="swal2-select">
                        ${itemOptions}
                    </select>

                    <button id="newItemBtn" class="btn btn-primary" style="margin-top:5px;">Add New Item</button>
                </div>
            `,
            showCancelButton: true,
            confirmButtonText: "Assign Item",
            didOpen: () => {
                document.getElementById('newItemBtn').addEventListener('click', () => {
                    // Open new item modal (your existing add-item logic)
                    openAddItemModal(null); // pass null or handle differently for creating item
                });
            },
            preConfirm: () => {
                const selectedPokemon = document.getElementById('selectPokemon').value;
                const selectedItem = document.getElementById('selectItem').value;
                if (!selectedPokemon || !selectedItem) {
                    Swal.showValidationMessage("Please select both Pok√©mon and item");
                    return false;
                }
                return { pokemonGuid: selectedPokemon, itemId: selectedItem };
            }
        }).then(result => {
            if (result.isConfirmed) {
                const { pokemonGuid, itemId } = result.value;
                const pokemon = currentPokesOnField.find(p => p.guid === pokemonGuid);

                // assign item to Pok√©mon via API
                fetch(`${BASE_URL}/addItemToBag/${GAME_ID}/${pokemon.guid}/${itemId}`, {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                })
                .then(res => res.json())
                .then(data => {
                    Swal.fire({
                        theme: "dark",
                        title: "Item Assigned",
                        text: `Item assigned to ${pokemon.name}!`,
                        toast: true,
                        position: "top-end",
                        timer: 3000,
                        timerProgressBar: true,
                        showConfirmButton: false,
                        theme: "dark"
                    });
                    pokemon.heldItem = items.find(i => i.id == itemId); // Update card UI
                    renderStage(currentPokesOnField);
                })
                .catch(err => Swal.fire('Error', 'Failed to assign item', 'error'));
            }
        });
    }

    function openAddItemModal(onCreatedCallback = null) {
        Swal.fire({
            title: "Add New Item",
            theme: "dark",
            html: `
                <div style="display:flex; flex-direction:column; gap:8px; text-align:left;">
                    <label>Name</label>
                    <input id="itemName" class="swal2-input">

                    <label>Description</label>
                    <textarea id="itemDesc" class="swal2-textarea"></textarea>

                    <label>Effect Key</label>
                    <input id="effectKey" class="swal2-input" placeholder="heal_hp, boost_stat">

                    <label>Effect Data (JSON)</label>
                    <textarea id="effectData" class="swal2-textarea"
                        placeholder='{"amount":20}'></textarea>

                    <div class="mb-3">
                        <label>Item Category</label>
                        <select id="itemCategory" name="ItemCategory" class="swal2-select" required>
                            {% for key, value in item_categories %}
                                <option value="{{ key }}" {% if loop.first %}selected{% endif %}>{{ value }}</option>
                            {% endfor %}
                        </select>
                    </div>
                    <div class="mb-3">
                        <label>Minimum Shop Tier</label>
                        <select id="minShopTier" name="MinShopTier" class="swal2-select" required>
                            {% for key, value in shop_tiers %}
                                <option value="{{ key }}" {% if loop.first %}selected{% endif %}>{{ value }}</option>
                            {% endfor %}
                        </select>
                    </div>

                    <label>Is Usable</label>   
                    <input id="isUsable" type="checkbox" class="swal2-input" value="0">

                    <label>Is Equipable</label>   
                    <input id="isEquipable" type="checkbox" class="swal2-input" value="0">

                    <label>Buy Price</label>
                    <input id="buyPrice" type="number" class="swal2-input" value="0">

                    <label>Sell Price</label>
                    <input id="sellPrice" type="number" class="swal2-input" value="0">

                    <label>Uses</label>
                    <input id="numUses" type="number" class="swal2-input" value="1">
                </div>
            `,
            showCancelButton: true,
            confirmButtonText: "Create Item",
            preConfirm: () => {
                try {
                    const effectDataRaw = document.getElementById("effectData").value;
                    const effectData = effectDataRaw ? JSON.parse(effectDataRaw) : null;

                    return {
                        name: document.getElementById("itemName").value,
                        description: document.getElementById("itemDesc").value,
                        effectKey: document.getElementById("effectKey").value,
                        effectData: effectData,
                        itemCategory: document.getElementById("itemCategory").value,
                        minShopTier: document.getElementById("minShopTier").value,
                        isUsable: document.getElementById("isUsable").checked,
                        isEquipable: document.getElementById("isEquipable").checked,
                        buyPrice: Number(document.getElementById("buyPrice").value),
                        sellPrice: Number(document.getElementById("sellPrice").value),
                        numUses: Number(document.getElementById("numUses").value),
                    };
                } catch {
                    Swal.showValidationMessage("Effect Data must be valid JSON");
                    return false;
                }
            }
        }).then(result => {
            if (!result.isConfirmed) return;

            fetch(`${BASE_URL}/Item`, {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify(result.value)
            })
            .then(res => res.json())
            .then(item => {
                items.push(item);

                Swal.fire({
                    toast: true,
                    position: "top-end",
                    title: "Item Created",
                    icon: "success",
                    timer: 2500,
                    showConfirmButton: false,
                    theme: "dark"
                });

                if (onCreatedCallback) {
                    onCreatedCallback(item);
                }
            })
            .catch(() => Swal.fire("Error", "Failed to create item", "error"));
        });
    }

    function openAddMoveModal(onCreatedCallback = null) {
        Swal.fire({
            title: "Add New Move",
            theme: "dark",
            width: "60rem",
            html: `
            <style>
            .swal2-popup .swal-move-form select {
                min-height: unset !important;
            }

            .swal-move-form {
                display: grid;
                grid-template-columns: 1fr 1fr;
                gap: 12px 24px;
                text-align: left;
            }

            .swal-move-form label {
                font-weight: bold;
                font-size: 0.9rem;
                margin-top: 6px;
            }

            .swal-move-form input,
            .swal-move-form select {
                padding: 6px;
                width: 100%;
                box-sizing: border-box;
                font-size: 0.9rem;
                color: hotpink;
                height: 40px;
                line-height: 40px;
                padding: 6px;
                background-color: transparent;
                border-radius: 12.5px;
            }

            .swal-move-form input:not([type="checkbox"]) {
                height: 32px;
                padding: 6px;
            }

            .swal-move-form input[type="checkbox"] {
                width: auto;
                margin-top: 8px;
            }
            </style>

            <div class="swal-move-form">

            <label>Name</label>
            <input id="Name">

            <label>Effect Text</label>
            <input id="effectText">

            <label>Flavor Text</label>
            <input id="flavorText">

            <label>Base Power</label>
            <input id="basePower" type="number" value="0">

            <label>Reduced Accuracy</label>
            <input id="reducedAccuracy" type="number" value="0">

            <label>Type</label>
            <select style="max-height 100px !important;" id="types">
                {% for item in moveData.types %}
                <option value="{{ item.id }}">{{ item.value }}</option>
                {% endfor %}
            </select>

            <label>Damage Type</label>
            <select id="damageTypes">
                {% for item in moveData.damageTypes %}
                <option value="{{ item.id }}">{{ item.value }}</option>
                {% endfor %}
            </select>

            <label>Priority</label>
            <select name="priority">
                {% for item in moveData.priority %}
                    {% if item.value != 0 %}
                        <option value="{{ item.value }}">{{ item.value }}</option>
                    {% else %}
                        <option selected value="{{ item.value }}">{{ item.value }}</option>
                    {% endif %}
                {% endfor %}
            </select>

            <label>Target</label>
            <select id="targets">
                {% for item in moveData.targets %}
                <option value="{{ item.id }}">{{ item.value }}</option>
                {% endfor %}
            </select>

            <label>Move Range Type</label>
            <select id="moveRangeType">
                {% for item in moveData.moveRangeTypesEnum %}
                <option value="{{ item.id }}">{{ item.value }}</option>
                {% endfor %}
            </select>

            <label>Grid Range</label>
            <input id="moveGridRange" type="number" value="1">

            <label>Hit Count</label>
            <select id="multiHits">
                {% for item in moveData.multiHits %}
                <option value="{{ item.value }}">{{ item.value }}</option>
                {% endfor %}
            </select>

            <label>Heal Type</label>
            <select id="healTypes">
                {% for item in moveData.healTypes %}
                <option value="{{ item.id }}">{{ item.value }}</option>
                {% endfor %}
            </select>

            <label>Accuracy Modifier 1</label>
            <select id="accuracyModifier1">
                {% for item in moveData.accuracyModifiers %}
                <option value="{{ item.id }}">{{ item.value }}</option>
                {% endfor %}
            </select>

            <label>Accuracy Modifier 2</label>
            <select id="accuracyModifier2">
                {% for item in moveData.accuracyModifiers %}
                <option value="{{ item.id }}">{{ item.value }}</option>
                {% endfor %}
            </select>

            <label>Accuracy Modifier 3</label>
            <select id="accuracyModifier3">
                {% for item in moveData.accuracyModifiers %}
                <option value="{{ item.id }}">{{ item.value }}</option>
                {% endfor %}
            </select>

            <label>Damage Modifier 1</label>
            <select id="damageModifier1">
                {% for item in moveData.damageModifiers %}
                <option value="{{ item.id }}">{{ item.value }}</option>
                {% endfor %}
            </select>

            <label>Damage Modifier 2</label>
            <select id="damageModifier2">
                {% for item in moveData.damageModifiers %}
                <option value="{{ item.id }}">{{ item.value }}</option>
                {% endfor %}
            </select>

            <label>Damage Modifier 3</label>
            <select id="damageModifier3">
                {% for item in moveData.damageModifiers %}
                <option value="{{ item.id }}">{{ item.value }}</option>
                {% endfor %}
            </select>

            {% for field in moveData.booleanFields %}
                <label>{{ field }}</label>
                <input type="checkbox" id="{{ field }}">
            {% endfor %}

            </div>
            `,
            showCancelButton: true,
            confirmButtonText: "Create Move",
            preConfirm: () => {
                const payload = {
                    Name: document.getElementById("Name").value,
                    effectText: document.getElementById("effectText").value,
                    flavorText: document.getElementById("flavorText").value,
                    basePower: Number(document.getElementById("basePower").value),
                    reducedAccuracy: Number(document.getElementById("reducedAccuracy").value),
                    types: document.getElementById("types").value,
                    damageTypes: document.getElementById("damageTypes").value,
                    priority: document.getElementById("priority").value,
                    targets: document.getElementById("targets").value,
                    moveRangeType: document.getElementById("moveRangeType").value,
                    moveGridRange: Number(document.getElementById("moveGridRange").value),
                    multiHits: document.getElementById("multiHits").value,
                    healTypes: document.getElementById("healTypes").value,
                    accuracyModifier1: document.getElementById("accuracyModifier1").value,
                    accuracyModifier2: document.getElementById("accuracyModifier2").value || null,
                    accuracyModifier3: document.getElementById("accuracyModifier3").value || null,
                    damageModifier1: document.getElementById("damageModifier1").value,
                    damageModifier2: document.getElementById("damageModifier2").value || null,
                    damageModifier3: document.getElementById("damageModifier3").value || null,
                };

                {% for field in moveData.booleanFields %}
                    if (document.getElementById("{{ field }}").checked) {
                        payload["{{ field }}"] = true;
                    }
                {% endfor %}

                return payload;
            }
        }).then(result => {
            if (!result.isConfirmed) return;

            fetch(`${BASE_URL}/addMove`, {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify(result.value)
            })
            .then(res => res.json())
            .then(data => {
                Swal.fire({
                    toast: true,
                    position: "top-end",
                    icon: "success",
                    title: "Move Created",
                    timer: 2500,
                    showConfirmButton: false,
                    theme: "dark"
                });

                if (onCreatedCallback) {
                    onCreatedCallback(data);
                }
            })
            .catch(() => Swal.fire("Error", "Failed to create move", "error"));
        });
    }

    // Step 2b: select target(s) for XP or Money
    function selectTargetsForValue(type) {
        Swal.fire({
            title: `Give ${type} to`,
            theme: "dark",
            showCancelButton: true,
            showConfirmButton: false,
            html: `
                <div style="display:flex; flex-direction:column; gap:10px;">
                    <button id="singleBtn" class="swal2-confirm swal2-styled">Single Pok√©mon</button>
                    <button id="allBtn" class="swal2-confirm swal2-styled">All non-NPC Pok√©mon</button>
                </div>
            `,
            didOpen: () => {
                const popup = Swal.getPopup();
                popup.querySelector("#singleBtn").addEventListener('click', () => {
                    Swal.close();
                    chooseSinglePokemon(type);
                });
                popup.querySelector("#allBtn").addEventListener('click', () => {
                    Swal.close();
                    enterValueForTargets(type, currentPokesOnField.filter(p => !p.isNPC));
                });
            }
        });
    }

    // Step 3a: choose a single Pok√©mon for XP or Money
    function chooseSinglePokemon(type) {
        const options = currentPokesOnField
            .filter(p => !p.isNPC)
            .map(p => `<option value="${p.guid}">${p.name}</option>`)
            .join('');

        Swal.fire({
            title: `Select Pok√©mon to give ${type}`,
            theme: "dark",
            html: `<select id="selectSinglePokemon" class="swal2-select">${options}</select>`,
            showCancelButton: true,
            confirmButtonText: "Next",
            preConfirm: () => document.getElementById('selectSinglePokemon').value
        }).then(result => {
            if (result.isConfirmed) {
                const target = currentPokesOnField.find(p => p.guid === result.value);
                enterValueForTargets(type, [target]);
            }
        });
    }

    // Step 3b: enter the amount of XP or Money
    function enterValueForTargets(type, targets) {
        Swal.fire({
            title: `Enter amount of ${type}`,
            theme: "dark",
            input: 'number',
            inputAttributes: { min: 0 },
            showCancelButton: true,
            confirmButtonText: 'Give',
            preConfirm: (value) => {
                if (!value || value < 0) Swal.showValidationMessage(`Please enter a valid ${type}`);
                return value;
            }
        }).then(result => {
            if (result.isConfirmed) {
                const amount = parseInt(result.value);
                targets.forEach(p => {
                    if (type === "XP") {
                        p.ExperiencePoints = (p.ExperiencePoints || 0) + amount;
                        // optionally update backend
                        fetch(`${BASE_URL}/addXp/${GAME_ID}/${p.guid}`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ xp: amount })
                        });
                    } else if (type === "Money") {
                        p.Money = (p.Money || 0) + amount;
                        // optionally update backend
                        fetch(`${BASE_URL}/addMoney/${GAME_ID}/${p.guid}`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ money: amount })
                        });
                    }
                });

                Swal.fire({
                    toast: true,
                    theme: "dark",
                    position: 'top-end',
                    icon: 'success',
                    title: `${type} successfully given!`,
                    showConfirmButton: false,
                    timer: 2000
                });
            }
        });
    }

    function weightedRandom(items, getWeight) {
    const weights = items.map(getWeight);
    const total = weights.reduce((a, b) => a + b, 0);

    let roll = Math.random() * total;

    for (let i = 0; i < items.length; i++) {
        roll -= weights[i];
        if (roll <= 0) {
        return items[i];
        }
    }

    return items[items.length - 1]; // fallback
    }

    function pickRandomPlayerTarget() {
    const players = currentPokesOnField.filter(
        p => !p.isNpc && typeof p.distance === "number"
    );

    if (!players.length) {
        Swal.fire({
        theme: "dark",
        icon: "warning",
        title: "No valid player targets",
        toast: true,
        position: "top-end",
        timer: 2500,
        showConfirmButton: false,
        });
        return null;
    }

    const target = weightedRandom(players, p => {
        const dist = Math.abs(p.distance ?? 0);
        return 1 / (1 + dist);
    });

    return target;
    }
    // quick search filtering
    let searchTimer = null;
    searchInput.addEventListener('input', ()=>{ clearTimeout(searchTimer); searchTimer = setTimeout(()=>renderSelects(allPokemonCache), 250) });

    // initial load
    loadAll();

    // ---- NOTES for backend integration (also in footer):
    // - GET /api/game/pokemons should return JSON { pokemons: [ { Guid, name, isNpc, level, status, baseHealth, health, primaryType, secondaryType, heldItem, ... } ] }
    // - POST /api/pokemon/batch accepts { guids: [...] } and returns { pokemons: [ ...full objects... ] }
    // - If your backend uses different field names, adapt the script to map them (e.g. Guid vs guid)
    // - You may want to enable CORS on port 9000 or serve frontend from the same origin.

    const addItemFormHtml = `
<form id="addItemForm" style="text-align:left;">
    <div class="mb-3">
        <label>Name</label>
        <input type="text" name="Name" class="form-control" required>
    </div>
    <div class="mb-3">
        <label>Description</label>
        <input type="text" name="Description" class="form-control">
    </div>
    <div class="mb-3">
        <label>Effect</label>
        <input type="text" name="Effect" class="form-control">
    </div>
    <div class="mb-3">
        <label>Item Category</label>
        <select name="ItemCategory" class="form-select" required>
            {% for key, value in item_categories %}
                <option value="{{ key }}" {% if loop.first %}selected{% endif %}>{{ value }}</option>
            {% endfor %}
        </select>
    </div>
    <div class="mb-3">
        <label>Minimum Shop Tier</label>
        <select name="MinShopTier" class="form-select" required>
            {% for key, value in shop_tiers %}
                <option value="{{ key }}" {% if loop.first %}selected{% endif %}>{{ value }}</option>
            {% endfor %}
        </select>
    </div>
    <div class="mb-3">
        <label>Buy Price</label>
        <input type="number" name="BuyPrice" class="form-control">
    </div>
    <div class="mb-3">
        <label>Sell Price</label>
        <input type="number" name="SellPrice" class="form-control">
    </div>
    <button type="submit" class="btn btn-primary">Add Item</button>
</form>
`;

    let globalAddResourceBtn = document.getElementById("globalAddResourceBtn");
    let globalRemoveResourceBtn = document.getElementById("globalRemoveResourceBtn");
    let genLootItemBtn = document.getElementById("genLootItemBtn");
    let toggleShopBtn = document.getElementById("toggleShopBtn");

    const initiativePanel = document.getElementById("initiativePanel");
    const targetBtn = document.createElement("button")
    targetBtn.textContent = "Random Player Target";
    targetBtn.className = "btn"
    targetBtn.style.marginTop = "10px"
    targetBtn.style.display = "None"
    initiativePanel.appendChild(targetBtn)

    if (!genLootItemBtn) {
        genLootItemBtn = document.createElement("button");
        genLootItemBtn.id = "genLootItemBtn";
        genLootItemBtn.textContent = "Generate Loot Item";
        genLootItemBtn.className = "btn btn-success";
        genLootItemBtn.style.marginTop = "10px";
        genLootItemBtn.style.marginRight = "10px";
        genLootItemBtn.style.display = "none"

        // Example: open modal for selected player(s)
        genLootItemBtn.onclick = async () => {
            const res = await fetch(`${BASE_URL}/genLootItem`);
            const data = await res.json();
            console.log(data); // { item: "SomeItemName" }
            Swal.fire({
                theme: "dark",
                icon: "question",
                title: "Loot Item",
                text: `You found: ${data.item[1]}`,
            })
        };

        const actionPanel = document.getElementById("actionPanel");
        actionPanel.appendChild(genLootItemBtn);
    }

    if (!toggleShopBtn) {
        toggleShopBtn = document.createElement("button");
        toggleShopBtn.id = "toggleShopBtn";
        toggleShopBtn.textContent = "Toggle Shop";
        toggleShopBtn.className = "btn btn-success";
        toggleShopBtn.style.marginTop = "10px";
        toggleShopBtn.style.marginRight = "10px";
        toggleShopBtn.style.display = "none"

        toggleShopBtn.onclick = async () => {
            const res = await fetch(`${BASE_URL}/Shop`, {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({ gameId: GAME_ID }),
            })

            const data = await res.json()

            if (!res.ok) {

            }

            Swal.fire({
                title: `Shop Status:  ${data.shopActive}`,
                toast: true,
                position: "top-end",
                theme: "dark",
                icon: "success",
                showConfirmButton: false,
                timer: 3000,
                timerProgressBar: true,
            })
        };

        const actionPanel = document.getElementById("actionPanel");
        actionPanel.appendChild(toggleShopBtn);
    }


    if (!globalAddResourceBtn) {
        globalAddResourceBtn = document.createElement("button");
        globalAddResourceBtn.id = "globalAddResourceBtn";
        globalAddResourceBtn.textContent = "Add Resource";
        globalAddResourceBtn.className = "btn btn-success";
        globalAddResourceBtn.style.marginTop = "10px";
        globalAddResourceBtn.style.display = "none"

        globalAddResourceBtn.onclick = () => {
            const selectedPlayers = currentPokesOnField.filter(p => !p.isNpc);
            openGiveResourcesModal(selectedPlayers);
        };

        const actionPanel = document.getElementById("actionPanel");
        actionPanel.appendChild(globalAddResourceBtn);
    }

    targetBtn.addEventListener("click", () => {
        const target = pickRandomPlayerTarget();
        if (!target) return;

        Swal.fire({
            theme: "dark",
            title: "Target Selected",
            html: `
            <strong>${target.name}</strong><br>
            Distance: ${target.distance}
            `,
            icon: "info",
            toast: true,
            position: "top-end",
            timer: 3000,
            showConfirmButton: false,
        });
    });

    if (!globalRemoveResourceBtn) {
        globalRemoveResourceBtn = document.createElement("button")
        globalRemoveResourceBtn.id = "globalRemoveResourceBtn";
        globalRemoveResourceBtn.textContent = "Remove Resource";
        globalRemoveResourceBtn.className = "btn btn-success";
        globalRemoveResourceBtn.style.marginTop = "10px";
        globalRemoveResourceBtn.style.marginLeft = "10px";
        globalRemoveResourceBtn.style.display = "none";

        globalRemoveResourceBtn.onclick = async () => {
            const players = currentPokesOnField.filter(p => !p.isNpc);

            if (!players.length) return;

            const { value: selectedGuid } = await Swal.fire({
                title: "Select Player",
                input: "select",
                inputOptions: Object.fromEntries(
                players.map(p => [p.guid, p.name])
                ),
                theme: "dark",
                showCancelButton: true,
            });

            if (!selectedGuid) return;

            const pokemon = players.find(p => p.guid === selectedGuid);
            const itemOptionsHtml = pokemon.Bag.items
            .map(bi => `<option value="${bi.bagItemId}">${bi.item.name}</option>`)
            .join("");

            const { value: result } = await Swal.fire({
            title: "Remove Resources",
            html: `
                <input id="rm-apples" type="number" class="swal2-input" placeholder="Apples">
                <input id="rm-xp" type="number" class="swal2-input" placeholder="XP">

                <label style="display:block;text-align:left;margin-top:10px;">
                <strong>Remove Items:</strong>
                </label>
                <select
                id="rm-items"
                class="swal2-select"
                multiple
                size="5"
                style="width:100%;"
                >
                ${itemOptionsHtml}
                </select>
            `,

            theme: "dark",
            showCancelButton: true,
            preConfirm: () => {
                const apples = Number(document.getElementById("rm-apples").value) || 0;
                const xp = Number(document.getElementById("rm-xp").value) || 0;

                const select = document.getElementById("rm-items");
                const items = select
                    ? [...select.selectedOptions].map(opt => Number(opt.value))
                    : [];

                if (apples <= 0 && xp <= 0 && items.length === 0) {
                    Swal.showValidationMessage("Select at least one resource to remove");
                    return false;
                }

                return {
                    apples,
                    xp,
                    items
                };
            }
            });
            console.log(result)
            console.log(result.items)
            if (!result) return;

            await fetch(`${BASE_URL}/removeResources`, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
                pokemonGuid: selectedGuid,
                removeApples: result.apples,
                removeXp: result.xp,
                removeBagItemIds: result.items
            })
            });
        }

        const actionPanel = document.getElementById("actionPanel");
        actionPanel.appendChild(globalRemoveResourceBtn);
    }

  </script>
</body>
</html>
